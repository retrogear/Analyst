 LST OFF
 SBTL 
 MSB ON
 ORG $6000 
 SKP 1 
*********************************
*                               *
*       -< THE ANALYST >-       *
*                               *
*          64K VERSION          *
*                               *
*            5/09/91            *
*                               *
*********************************
 SKP 1 
*** DESCRIPTION *** 
 SKP 1 
; THIS PROGRAM OPERATES INDEPENDENT OF ROM BUT HAS COM-
; MANDS SIMILAR TO THE BUILT IN MONITOR. THE TRACE AND
; STEP FUNCTIONS HAVE BEEN GREATLY ENHANCED TO DISPLAY
; STATUS REGISTER FLAGS AND SET A BREAK POINT. THE MINI
; ASSEMBLER HAS BEEN INCLUDED AS WELL AS A HEX SEQUENCE
; FINDER. 65C02 OPCODES ARE ALSO SUPPORTED. ZERO PAGE
; REFS ARE STORED IN A BUFFER WHICH AVOIDS CONFLICT WITH
; THE PROGRAM BEING TRACED. THIS PROGRAM USES THE BOTTOM
; 1/2 OF THE STACK ($100-180).
 SKP 1 
*** COMMANDS ***
 SKP 1 
; CTRL-F   FIND SPECIFIED HEX SEQUENCE DEFINED BY F(H)
;      G   GO EXECUTE IN IMMEDIATE MODE  
;      H   LOAD BYTES FOR HSF F(CTRL-F) BY USING H: 
;      I   DISPLAY/SET PC/INTERNAL A,X,Y,P,S REGISTERS
;      J   JUMP. EXECUTE JSR INSTRUCTION IN STEP MODE
; CTRL-L   CLEAR PRESENT SCREEN AND HOME CURSOR
;      L   LIST DISASSEMBLY OR LOOP IN TRACE MODE.
;      M   MOVE BLOCK OF MEMORY
;      P   SEND OUTPUT TO PRINTER
;      R   RELOCATE ANALYST TO NEW ADDRESS PAGE
;      S   ENTER STEP MODE. STEP INSTRUCTION
;      T   TRACE PROGRAM
;      V   VERIFY TWO BLOCKS OF MEMORY
;      X   SKIP NEXT INSTRUCTION IN STEP MODE
;      "   DUMP MEMORY IN ASCII 
;      /   SET OR PRINT SUBROUTINE TO JSR IMMED MODE
;      %   PRINT ADDRESS DATA VALUE IN BINARY
;      ?   PRINT ORIGIN ADDRESS & DO INTERNAL CHECKSUM
;      @   SET TEXT 40/80 COL SCREEN
;      <   RANGE DELIMITER
;      .   RANGE DELIMITER
;      +   16 BIT ADDITION
;      -   16 BIT SUBTRACTION
;      :   STORE VALUE IN MEMORY
;      !   ENTER MINI-ASSEMBLER. <CR> ALONE TO EXIT 
 SKP 1
*** OPERATING NOTES ***
 SKP 1 
; INPUT LINE LIMITED TO 38 CHARACTERS. BEEPS ON LAST 4.
 SKP 1
; HOME (CTRL-L) ACTS IMMEDIATELY. FOLLOW WITH <CR>.
 SKP 1
; FOR STEP TYPE 300S <CR> THEN S, OPEN-APPLE, SPACE, OR
; J TO STEP EACH INSTRUCTION. S OR OPEN-APPLE TO STEP
; INTO JSR. J TO EXECUTE SUBROUTINE. X TO SKIP INSTRUC-
; TION. T TO ENTER TRACE. @ FOR TEXT. L FOR LOOP.
; CTRL-C TO EXIT. LOOP COMMAND SETS BREAKPOINT AFTER
; INSTRUCTION TO BE EXECUTED NEXT AND ENTERS TRACE. CAN
; BE USED ON BRANCH WHICH LOOPS BACK TO TRACE OUT OF
; LOOP. @ WILL EXECUTE NEXT INSTRUCTION. PC SAVED ON
; EXIT AND CAN BE RESTORED BY CTRL-E EXAMINE REGISTERS.
 SKP 1
; FOR TRACE TYPE 2000T OR T <CR>. BREAKPOINT IS OPTIONAL
; AND DESIGNATED BY NNNN<2000T. SAME FOR STEP MODE.
; PC PRINTED AT TOP RIGHT EVERY 256 LINES. OPEN APPLE
; ENTERS SLOW TRACE WITH PC PRINTED EACH LINE. CLOSED 
; APPLE EXITS TO STEP MODE. TRACE WILL EXECUTE  SUB-
; ROUTINE SPECIFIED BY NNNN/ IN IMMEDIATE MODE TO ENABLE
; TRACING ACROSS DOS CALLS. USE FFFF/ TO TRACE ALL. '/'
; ALONE PRINTS VALUE. ROM $C000-FFFF WILL JSR IMMEDIATE
; MODE EXCEPT SETTING ORG+$FFF <> 0 ( NFFF:NN ) WILL EN-
; ABLE TRACING THRU JSR ROM $D000-FFFF BECAUSE CERTAIN
; ROM ROUTINES WHICH INVOLVE SETTING I/O AND DOS HOOKS
; DON'T RTS TO ANALYST. TRACE ACTIVITY DENOTED BY FLASH-
; ING $ OR # FOR JSR IMMEDIATE MODE. BREAKPOINT ENTERS
; STEP MODE AND DOES EXECUTE BREAKPOINT INSTRUCTION.
 SKP 1
; FOR JUMP TYPE 'J5' WHERE 5 REPRESENTS # OF PARM BYTES 
; FOLLOWING JSR INSTRUCTION. J<CR> DEFAULTS TO 0. JUMP
; DURING STEP & TRACE IMMEDIATE HANDLE JSR $BF00 AS
; PRODOS MLI CALL WITH 3 PARM BYTES FOLLOWING. MUST USE
; 'J3' FROM COMMAND LINE. IF SUBROUTINE BEING 'JUMPED'
; CONTAINS A TXS INSTRUCTION, ANALYST MAY LOSE CONTROL!
; ALSO TRACE IMMEDIATE WILL NOT HANDLE A SUBROUTINE
; OTHER THAN $BF00 WITH PARM BYTES FOLLOWING! F(J) USES
; STACK IN ANALYST AREA. COULD EXEC J5 BY NNNN+8<NNNNG
; WHICH WOULD USE SPNT. NNNN+8 AREA WOULD HAVE TO BE
; R/W ENABLED BEFORE AND AFTER CALL!
 SKP 1
; STEP & TRACE BREAK FOR ILLEGAL OPCODES. PRINTS 'ERR' 
 SKP 1
; TO DISPLAY PC AND INTERNAL REGISTERS TYPE I <CR>.
; TO CHANGE PC AND/OR INTERNAL REGS TYPE 300I:AA XX 
; YY PP SS RR <CR>. PC ENTRY BEFORE I OPTIONAL. RR =
; STACK TOP REFERENCE SET BY A TXS INSTRUCTION.
 SKP 1 
; FOR HEX SEQUENCE FINDER TYPE H:N1 N2 N3... <CR> THEN
; 1000<2000 CTRL-F <CR>. 8 BYTES MAX BECAUSE IN DS 29.
 SKP 1 
; TO DUMP MEMORY IN ASCII USE 1000.2000" <CR>. 
 SKP 1
; TO PRINT ADDRESS BYTE IN BINARY TYPE 2000% <CR>.
 SKP 1
; TO SWITCH SCREENS TYPE @8,@4 OR @ FOR TEXT.
 SKP 1 
; TO RELOCATE TYPE NN00R <CR>. WILL ROUND OFF TO NEAREST
; PAGE BOUNDARY. DO NOT SET < $800! DO NOT MOVE < +- 4K
; FROM OLD ORIGIN! IF MOVED TO RAM CARD DO NOT CHANGE
; CARD R/W STATE!
 SKP 1
; RESET VECTOR $3F2 CAN BE SET MANUALLY TO ORIGIN ADDR.
 SKP 1
; DO NOT USE THE PRINTER WHEN THE ANALYST IS LOCATED
; ON THE RAM CARD. THE PRINTER WILL NOT INITIALIZE.
; ALSO RESET WILL NOT RETURN TO THE ANALYST LOCATED
; ON THE RAM CARD.
 SKP 1
; BY INSERTING JSR ORG+$0B A WARMSTART RE-ENTRY CAN
; BE USED TO JMP INTO ANALYST FROM A RUNNING PROGRAM
; WITH ALL REGS PRESERVED.
 SKP 1
; TO STEP AND TRACE AUX MEMORY, ANALYST SHOULD BE IN
; 80 COLUMN MODE.
 SKP 1
; TO USE DOS TYPE 3F5<3D0G, THEN USE & TO RE-ENTER.
; TO USE BASIC W/PRODOS TYPE $F1:00 AND $1FC:01 01.
 SKP 1
*** ROM ZERO PAGE EQUATES *** 
 SKP 1
WNDWDTH EQU $21
MCH EQU $24
MBASL EQU $28
MCSWL EQU $36
MCSWH EQU $37
MKSWL EQU $38
MKSWH EQU $39
 SKP 1
*** ANALYST EQUATES ***
 SKP 1
STKLMT EQU $80 TOP OF STACK (IMMEDIATE)
PCL EQU $EF LABEL MARKS PAGE 0 
PCH EQU $F0
BASL EQU $F1
BASH EQU $F2 LABEL USED AS IDENTIFIER
ZFLG EQU $F3 1 BYTE ID = $AA
A1L EQU $F4 A1L-A5H MUST BE IN ORDER
A1H EQU $F5 FOR MINI-ASSEMBLER 
A2L EQU $F6 
A2H EQU $F7 
A3L EQU $F8 
A3H EQU $F9 
A4L EQU $FA 
A4H EQU $FB 
A5L EQU $FC 
A5H EQU $FD 
BAS2L EQU $FE
BAS2H EQU $FF LABEL MARKS END OF PAGE 0
STACK EQU $0100
MLI EQU $BF00 PRODOS INTERFACE
 SKP 1
*** ROM EQUATES ***
 SKP 1
KBD EQU $C000
CLR80ROM EQU $C00A
CLR80VID EQU $C00C
KBDSTRB EQU $C010
SPKR EQU $C030
TXTSET EQU $C051
LOWSCR EQU $C054
PB0 EQU $C061 OPEN APPLE KEY
PB1 EQU $C062 CLOSED APPLE KEY
SWITCH2 EQU $C082
PRINIT EQU $C100 PRINTER IN SLOT 1
PR3 EQU $C300
IDROM EQU $E000 = $4C IF ROM PRESENT
MKEYIN EQU $FD1B
MVIDOUT EQU $FDF0
 SKP 3 
GETSUM JSR INITSUM CREATE CHECKSUM OF MAIN 
 LDA #$2C WHEN FIRST BRUN
SUMLOC STA GETSUM DISABLE CHECKSUM
 SKP 1
*** STATIC MAIN PROGRAM AREA ***
 SKP 1
START JMP RESET COLD START
WARMV JMP REENTER WARM START (BY JSR WARMV)
INSDS1 LDX PCL
 LDY PCH
 JSR PRYX2
 JSR OUTSP
 LDX #0
INSDST LDA (PCL,X)
INSDS2 LDY #$FF DETERMINE LENGTH OF
 STY LMNEM INSTRUCTION. OPCODE IN
 TAY  ACC. STORED IN LENGTH.
 LSR A INVALID =  0
 BCC IEVEN 1 BYTE = 0
 ROR A 2 BYTE = 1
 BCS ERR 3 BYTE = 2
 AND #$87
IEVEN LSR A
 TAX 
 LDA FMT1,X
 BCC RTMSKZ
 LSR A
 LSR A
 LSR A
 LSR A
RTMSKZ AND #$0F
 CMP #$0F
 BNE GETFMT
ERR LDY #$FF BAD OPCODE
 STY ERRFLG
 INY
 STY LMNEM
 STY RMNEM
 STY FORMAT
 STY LENGTH
RTS1 RTS
GETFMT TAX 
 LDA FMT2,X
 STA FORMAT
 AND #$03
 STA LENGTH
 LDA TFLG BYPASS PRINT FORMATTING
 BNE RTS1 IN TRACE
 TYA 
 AND #$8F
 STA FMTSAV TEMP STORAGE
 TYA 
 LDX #31
GETFMT2 DEX
 BMI MNNDX
 CMP OPC65C,X MAKE SUBSTITUTION IF
 BNE GETFMT2 65C02 OPCODE.
 LDA REPL65C,X
MNNDX LDX FMTSAV
 LDY #$03
 CPX #$8A
 BEQ MNNDX3
MNNDX1 LSR A
 BCC MNNDX3
 LSR A
MNNDX2 LSR A
 ORA #$20
 DEY 
 BNE MNNDX2
 INY 
MNNDX3 DEY 
 BNE MNNDX1
 RTS 
INSTDSP JSR INSDS1
 PHA 
PRNTOP LDA (PCL),Y
 JSR PRBYTE
 LDX #$01
PRNTBL JSR PRBLNK
 CPY LENGTH
 INY 
 BCC PRNTOP
 LDX #$03
 CPY #$03
 BCC PRNTBL
 PLA 
 TAY 
 LDA LMNEM
 BEQ PRMN1
 LDA MNEML,Y
 STA LMNEM
 LDA MNEMR,Y
 STA RMNEM
PRMN1 LDA #$00
 LDY #$05
PRMN2 ASL RMNEM
 ROL LMNEM
 ROL A
 DEY 
 BNE PRMN2
 ADC #$BF
 JSR COUT
 DEX 
 BNE PRMN1
 JSR OUTSP
 LDY LENGTH
 LDX #$05
PRADR1 CPX #$02
 BEQ PRADR5
PRADR2 ASL FORMAT
 BCC PRADR3
 LDA CHAR1,X
 JSR COUT
 LDA CHAR2,X
 BEQ PRADR3
 JSR COUT
PRADR3 DEX 
 BPL PRADR1
 RTS 
PRADR4 DEY 
 BMI PRADR2
 JSR PRBYTE
PRADR5 LDA FORMAT
 CMP #$E8
 LDA (PCL),Y
 BCC PRADR4
 JSR PCADJA
 TAX 
 INX 
 BNE PRNTYX
 INY 
PRNTYX TYA 
PRNTAX JSR PRBYTE 
 TXA 
 JMP PRBYTE
PRBLNK JSR OUTSP PRINT X SPACES
 DEX 
 BNE PRBLNK
 RTS 
PCADJ SEC  UPDATE PC BY LENGTH+1 
PCADJLP LDA LENGTH UPDATE PC BY LENGTH
PCADJAP JSR PCADJA UPDATE PC BY ACC
 STA PCL
 STY PCH
 RTS
PCADJL LDA LENGTH SET Y,A = PC+LENGTH 
PCADJA LDY PCH SET Y,A = PC+ACC 
 TAX 
 BPL PCADJ2
 DEY 
PCADJ2 ADC PCL
 BCC RTS2
 INY 
RTS2 RTS 
STEP DEC YSAV F(S)
 PLA  REMOVE RTS TO NEXTITM
 PLA
STEPL TXA
 BEQ STEPZ
 JSR SETBREAK FIRST TIME
 LDX #1
 BNE SSTEP ALWAYS TAKEN
STEPZ JSR KYWAIT CTRL-C = BREAK
 CPY #$CA
 BNE STEP2 
 LDA JFLG J = SINGLE STEP
 BEQ SSTEP IF NO JSR, ELSE
 JMP TRCPCS EXECUTE SUBROUTINE
STEP2 CPY #$CC L = LOOP. SET BREAK
 BNE STEP2A POINT AFTER INSTRUCTION
 JSR PCADJL TO BE EXECUTED NEXT
 STA BRKADDR AND ENTER TRACE.
 STY BRKADDR+1 
 JMP STEPT
STEP2A LDA JFLG SPC = SINGLE STEP IF
 BNE STEP3 NOT JSR, ELSE IGNORE
 CPY #$A0 
 BEQ SSTEP
STEP3 CPY #$D3 S OR OPEN APPLE =
 BEQ SSTEP SINGLE STEP ALWAYS
 TYA
 BEQ SSTEPW = 0 FOR OPEN APPLE.
 CPY #$D4 T = ENTER TRACE MODE
 BNE STEP4
STEPT STY TFLG SET TRACE MODE FLAG
 JMP TRACE4 AND ENTER TRACE.
STEP4 CPY #$D8 X = SKIP NEXT INSTRUCTION
 BNE STEP5
 LDA #0 ENABLE SPC IF SKP WHILE
 STA JFLG JSR DISPLAYED ACTIVE.
 STA ERRFLG CLR IN CASE SKIP ERROR.
 JSR PCADJ
 JMP JRTSX
STEP5 CPY #$C0 @ = TEXT MODE
 BNE STEPL LOOP BACK FOR INPUT
 JSR TEXT
SSTEPW LDA #$FF PAUSE TO RELEASE O/A KEY
 JSR WAIT
SSTEP JSR A1PC
SSTEPT JSR CLEARDSP TRACE RE-ENTRY TO STEP
 JSR INSTDSP
 LDX #3
 JSR PRBLNK
 LDA (PCL,X) X=0
 AND #$0F
 CMP #$01 SEE IF ZERO PAGE IND
 BNE SSTEPZ
 LDA #$A8 '('
 JSR COUT PRINT ABSOLUTE VALUE
 LDA (PCL,X) IN PARENTHESIS
 AND #$10
 BNE INDY TAKEN FOR (NN),Y.
 LDX XREG FOR (NN,X).
INDY TXA  X=0 FOR (NN),Y
 LDY #1
 CLC
 ADC (PCL),Y
 PHA
 JSR ZSWAP GET PROGRAM PAGE 0 AND
 PLA  SAVE POINTER ADDRESS ON
 TAX  STACK.
 LDA $01,X
 PHA
 LDA $00,X
 PHA
 JSR ZSWAP RESTORE ANALYST PAGE 0
 PLA  AND RECOVER POINTER ADDR.
 TAX
 PLA
 JSR PRNTAX
 LDA #$A9 ')'
 JSR COUT
SSTEPZ JMP TSTEP 
PRNTPC LDA #$FF PRINT PC AT TOP OF SCREEN
 STA CV BY FORCING CROUT TO INC
 JSR CROUT CV TO 0 (NEED FOR 80 COL)
 LDA #29
 STA CH
 LDA PROMPT
 JSR COUT
 LDA PCH
 LDX PCL
 JMP PRNTAX 
TRACEPC INC COUNTER PRINT PC  
 BNE TRCPC2 EVERY 256 INSTRUCTIONS 
 LDA PROMPT FLASHING '$' FOR TRACE
 EOR #$04 ACTIVITY. $A4->$A0->$A4
 STA PROMPT
 JSR PRNTPC
TRCPC2 LDA JFLG
 BEQ TRACE5
 LDA PCH
 CMP #$C0
 BCC TRCPCD
 CMP #$D0 JSR $C000-CFFF ALWAYS
 BCS TRCPCR IMMED MODE IF ANALYST
 LDY FLG8 IN 80 COL DISPLAY MODE.
 BMI TRCPCI
TRCPCR LDY ROMFLG
 BNE TRCPCD
 LDY IDROM JSR ROM $D000-FFFF IN
 CPY #$4C IMMEDIATE MODE UNLESS
 BEQ TRCPCI ROM FLAG SET <> 0.
TRCPCD CMP DOSCALL+1 TRACE THRU JSR UNLESS =
 BNE TRACE5 DOS SUBROUTINE SPECIFIED
 LDA PCL BY F(/).
 CMP DOSCALL
 BNE TRACE5
TRCPCI JSR STPRMPT '#' DENOTES JSR IMMED.
 JSR PRNTPC PRINT EXEC SUBROUTINE
 INC PROMPT '#' -> '$'
 LDA #$FF FORCE PC PRINTING
 STA COUNTER AFTER JSR IMMED.
TRCPCS LDA PCL SEE IF PC = $BF00
 BNE TRCPCG
 LDA PCH
 CMP #<MLI
 BNE TRCPCG
 LDY #3 3 PARMS FOR PRODOS MLI
 DFB $2C SKIP NEXT INSTRUCTION
TRCPCG LDY #0 0 PARMS FOR EXEC
 JMP GOPC
TRACE JSR A1PC F(T) A4<A1T A4=BRK TO STEP
 JSR SETBREAK SET OR CLEAR BREAKPOINT
 STX TFLG SET TRACE FLAG
TRACE4 INC PROMPT '#' -> '$' 1ST TIME ONLY
 JSR CLEARDSP
TRACE5 LDX #1 IF PC = A4 THEN ENTER STEP
TRACE6 LDA PCL,X
 CMP BRKADDR,X
 BNE TRACE7
 DEX
 BPL TRACE6
 JSR SETBREAK CLEAR OLD BREAKPOINT
 INX
 BEQ TRACES ALWAYS TAKEN
TRACE7 LDX #0 FOR INSDST
 LDA PB1 BACK TO STEP MODE IF
 BPL TRACE8 CLOSED APPLE PRESSED
TRACES STA KBDSTRB
 STX TFLG CLEAR TRACE FLAG
 STX DSPTOP RESET DISPLAY TO TOP
 JSR STPRMPT PROMPT BACK TO OLD '#'
 LDY YSAV
 LDA #$D3 PUT 'S' INTO INPUT BUFFER
 STA IN,Y
 JMP SSTEPT RE-ENTER STEP MODE
TRACE8 LDA PB0 SLOW TRACE IF OPEN APPLE
 BPL TRACE9 PRESSED
 LDA #$FF
 STA COUNTER FORCE PC PRINTING
 PHA 
 JSR WAIT
 PLA 
 JSR WAIT
TRACE9 JSR INSDST
TSTEP LDA ERRFLG IF BAD OPCODE THEN BRK 
 BEQ TSTEP3
XBRK LDA #0
 STA DSPTOP
 STA TFLG
 JSR CLEARDSP
 JSR INSTDSP
 JSR CROUT
 JSR RGDSP1
 JMP ERRMON
XTSX LDX SPNT
 STX XREG
XTXS LDX XREG
 STX SREF
UPDSPNT STX SPNT UPDATE SPNT
 CPX #STKLMT+1 STACK OVERFLOW IF
 BCC XBRK IN ANALYST WORK AREA
 JMP PCINC UPDATE PC
TSTEP3 TAX  = 0
 STX JFLG DISALLOW F(J) IF NO JSR 
 LDA (PCL,X) GET OPCODE (X=0)
 BEQ XBRK
 LDY LENGTH
 CMP #$20
 BEQ XJSR
 CMP #$60
 BEQ XRTS 
 CMP #$BA
 BEQ XTSX
 CMP #$9A
 BEQ XTXS
 CMP #$40
 BEQ XBRK BREAK FOR RTI INSTRUCTION
 CMP #$7C
 BEQ XJMPATX
 CMP #$4C
 BEQ XJMP
 CMP #$6C
 BEQ XJMPAT
 PHA
 CMP #$5A
 BCC TSTEP4
 TAX
 AND #$1F
 CMP #$1A
 BEQ STACKOP PHX,PLX,PHY,PLY
 TXA
TSTEP4 AND #$9F
 CMP #$08
 BNE TSTEP5
STACKOP JMP STKOPC PHA,PLA,PHP,PLP
TSTEP5 LDX #$08 
XQINIT LDA INITBL-1,X 
 STA XQT,X 
 DEX 
 BNE XQINIT
 PLA  OPCODE
 CMP #$80
 BNE NBRA
 ORA #$10
NBRA AND #$1F
 EOR #$14
 CMP #$04 = BRANCH OFFSET 
 BEQ XQ2 TAKEN IF BRANCH OPCODE 
XQ1 LDA (PCL),Y Y = LENGTH
XQ2 STA XQT,Y XQT   BCS BRNCH (B0 04)
 DEY        NOP 
 BPL XQ1       JMP NBRNCH (CCLR)
 JMP XQJ BRNCH JMP BRANCH (CSET)
XRTS LDX SPNT
 INX
 LDA STACK,X
 STA PCL
 INX
 LDA STACK,X
 STA PCH
 STX SPNT
 DEC DSPTOP
 JMP PCINC
XJMPATX INX
 BNE XJMPAT
XJSR STA JFLG OK FOR F(J) 
 INC DSPTOP
 CLC
 JSR PCADJL SET Y,A = RTS ADDR 
 PHA
 LDX SPNT
 TYA 
 STA STACK,X
 DEX 
 PLA 
 STA STACK,X
 DEX
 STX SPNT
 LDY #$02
XJMP CLC 
XJMPAT LDA (PCL),Y
 PHA 
 DEY 
 LDA (PCL),Y
 STA PCL
 PLA
 STA PCH
 BCC NEWPC
 DEX
 BNE XJMP
 LDA XREG
 CLC
 JSR PCADJAP
 LDY #1
 BNE XJMP ALWAYS TAKEN
NBRNCH JSR SAVE ALL OTHER OPCODES 
 BMI UPDPC ALWAYS TAKEN
BRANCH JSR SAVE BRANCH WITH COND. MET 
 CLC 
 LDY #$01
 LDA (PCL),Y
 JSR PCADJAP
UPDPC SEC
PCINC JSR PCADJLP
NEWPC LDA TFLG
 BNE TRACEBY BYPASSES NEXTITM
NXTPC JSR CROUT 
 JMP REGDSP
TRACEBY JMP TRACEPC
INITBL NOP 
 NOP 
 JMP NBRNCH
 JMP BRANCH
PULL PHP
 INX
 LDA STACK,X
 TAY
 LDA STATUS PULL FROM STACK AFFECTS
 PHA  N & Z FLAGS
 PLP
 TYA  UPDATE N & Z
 PHP
 PLA
 STA STATUS
 TYA
 PLP
 RTS
STKOPC LDX SPNT STACK OPCODES
 PLA  OPCODE
 TAY
 AND #$10
 BEQ APCODE
 TYA
 ASL A
 BCS OPCX
 ASL A
 ASL A
 BCS XPLY
 LDA YREG XPHY
 BCC PUSH
XPLY JSR PULL
 STA YREG
 BCS UPDSTACK
OPCX ASL A
 ASL A
 BCS XPLX
 LDA XREG XPHX
 BCC PUSH
XPLX JSR PULL
 STA XREG
 BCS UPDSTACK
APCODE TYA
 ASL A
 ASL A
 BMI PULLAP
 BCC XPHP
 LDA ACC XPHA
 BCS PUSH
XPHP LDA STATUS
PUSH STA STACK,X
 DEX
 BNE UPDSTACK
PULLAP BCC XPLP
 JSR PULL XPLA
ACCLOC STA ACC
 BCS UPDSTACK
XPLP JSR PULL
 STA STATUS
UPDSTACK JMP UPDSPNT
SETBREAK LDX #1 SET BREAKPOINT TO A4
 LDA BRKADDR+1 IF GIVEN, ELSE $FFFF.
 BEQ SETBRK2 BREAKPOINT GIVEN
 LDA #$FF
SETBRK1 STA BRKADDR,X CLEAR OLD BREAKPOINT
 DEX
 BPL SETBRK1
 BMI RTS2A ALWAYS TAKEN
SETBRK2 LDA A4L,X SET BREAKPOINT
 STA BRKADDR,X
 DEX
 BPL SETBRK2
RTS2A RTS
LOAD LDA XQLOC1+1 F(H)
 LDY XQLOC1+2 SETUP A3 = XQT+1 FOR HSF
 BNE A3SET BUFFER (XQT=BYTE COUNT)
SETRG1 JSR A1PC
 JSR SAVEPC
SETRG2 LDA ACCLOC+1 SETUP REGS FOR F(:)
 LDY ACCLOC+2
A3SET STA A3L
 STY A3H
 RTS
SETREG TXA  F(I) SET OR DISPLAY REGS.
 BNE SETRG1 TAKEN IF PC GIVEN.
 LDY YSAV
 LDA IN,Y
 CMP #$8D
 BNE SETRG2
 LDA PCREG I <CR> DISPLAYS REGS.
 STA PCL
 LDA PCREG+1
 STA PCH
REGDSP JSR RGDSP1
 JSR INSTDSP DISPLAY INSTRUCTION
 JMP NEXTITM TO BE EXECUTED NEXT
RGDSP1 LDX #0 
RDSP1 LDA RTBL,X 
 JSR COUT
 LDA #$BD
 JSR COUT
 LDA ACC,X 
 JSR PRBYTE
 JSR OUTSP
 INX 
 CPX #3
 BCC RDSP1
 LDX #7
PRFLG LDA CHAR3,X PRINT 'NV-BDIZC' 
 JSR COUT
 DEX 
 BPL PRFLG
 JSR CROUT 
 LDA #$C1 PRINT ACC IN BINARY
 JSR COUT 
 JSR OUTEQ
 LDA ACC
 JSR BNDSP
 LDX #3
 JSR PRBLNK
 LDA #$D0 PRINT STATUS IN BINARY
 JSR COUT
 JSR OUTEQ
 LDA STATUS
 JSR BNDSP
 JSR CROUT
 LDA #$D3
 JSR COUT
 JSR OUTEQ
 LDA SPNT
 JSR PRBYTE
 LDA #$BA
 JSR COUT
 LDA #$D8
 JSR COUT
 JSR COUT
 LDY #10
 LDX SPNT
PRNTSTK JSR OUTSP PRINT STACK BYTES FROM
 CPX SREF SPNT TO SREF UP TO 10
 BEQ SAVEPC MAX.
 INX
 LDA STACK,X
 JSR PRBYTE
 DEY
 BNE PRNTSTK
SAVEPC LDA PCL
 STA PCREG
 LDA PCH
 STA PCREG+1
 RTS
BINARY LDY #0 F(%) PRINT VALUE AT
 LDA (A1L),Y ADDRESS IN BINARY.
BNDSP LDX #$08 INDEX FOR 8 BITS 
NEXTBIT ASL A
 PHA 
 BCS BIT1
 LDA #$30 '0' 
 DFB $2C SKIP NEXT INSTRUCTION
BIT1 LDA #$31 '1' 
 JSR COUT
 PLA 
 DEX 
 BNE NEXTBIT 
 RTS 
BASCALC PHA
 LSR A
 AND #$03
 ORA #$04
 STA BASH
 PLA 
 AND #$18
 BCC BSCLC2
 ADC #$7F
BSCLC2 STA BASL
 ASL A
 ASL A
 ORA BASL
 STA BASL
 RTS 
BELL LDY #$38 DURATION 
BELL2 LDA #$2B FREQUENCY 
 JSR WAIT
 LDA SPKR
 DEY
 BNE BELL2
 RTS
VIDOUT CMP #$A0 
 BCC NOADV INVERSE, CTRL, OR FLASH
STOADV LDY CH
 STA (BASL),Y
 INC CH
 LDA CH
 CMP #$28
 BCS CR
RTS3 RTS 
NOADV TAY
 BPL STOADV INVERSE OR FLASH
 CMP #$8D
 BEQ CR
 CMP #$88
 BNE RTS3 DON'T PRINT CTRL CHARS.
 DEC CH BACKSPACE
 BPL RTS3
 LDA #$28
 STA CH
 DEC CH
UP LDA #$00
 CMP CV
 BCS RTS4
 DEC CV
VTAB LDA CV
VTABZ JSR BASCALC
 ADC #$00
 STA BASL
RTS4 RTS 
HOME40 LDA #$00
 STA CV
 LDY #$00
 STY CH
CLEOP1 PHA 
 JSR VTABZ
 JSR CLEOLZ
 LDY #$00
 PLA 
 ADC #$00
 CMP #$18
 BCC CLEOP1
 BCS VTAB
CR LDA #$00
 STA CH
 INC CV
 LDA CV
 CMP #$18
 BCC VTABZ
 DEC CV
 LDA #$00
 PHA 
 JSR VTABZ
SCRL1 LDA BASL BASL = CURRENT 
 STA BAS2L BAS2L = OLD 
 LDA BASH
 STA BAS2H
 LDY #$28
 DEY 
 PLA 
 ADC #$01
 CMP #$18
 BCS SCRL3
 PHA 
 JSR VTABZ
SCRL2 LDA (BASL),Y
 STA (BAS2L),Y
 DEY 
 BPL SCRL2
 BMI SCRL1
SCRL3 LDY #$00
 JSR CLEOLZ
 BCS VTAB ALWAYS TAKEN 
CLREOL LDY CH
CLEOLZ LDA #$A0
CLEOL2 PHA
 LDA FLG8
 BMI CLEOL3
 PLA
 STA (BASL),Y
 INY
 BNE CLEOL4 ALWAYS TAKEN
CLEOL3 PLA
 JSR COUT
 LDY CH
CLEOL4 CPY #$28
 BCC CLEOL2
 RTS
CLEARDSP LDX #6 CLEAR DISPLAY WINDOW
CLRDSP1 LDA DSPTOP
 BPL CLRDSP2 HOLD TOP OF DISPLAY
 LDA #0 0 <= TOP <= 18.
CLRDSP2 CMP #18
 BCC CLRDSP3
 LDA #18
CLRDSP3 STA DSPTOP
 STA CV CLEAR 6 LINE DISPLAY
 DEC CV FROM DSPTOP DOWN AND
 TXA  SET CV SO INSTDSP WILL
 BEQ RTS4A PRINT AT DSPTOP UPON
CLRDSP4 JSR CROUT EXIT.
 JSR CLREOL
 DEX
 BNE CLRDSP4
 BEQ CLRDSP1
RTS4A RTS
LWAIT LDA #$70 LIST SCROLL RATE
WAIT SEC 
WAIT2 PHA 
WAIT3 SBC #$01
 BNE WAIT3
 PLA 
 SBC #$01
 BNE WAIT2
 RTS 
NXTA4 INC A4L INCREMENT A4 
 BNE NXTA1
 INC A4H
NXTA1 LDA A1L
 CMP A2L
 LDA A1H
 SBC A2H
 INC A1L
 BNE RTS4B
 INC A1H
RTS4B RTS  CARRY SET IF A1 >= A2 
CTRLC LDY KBD CTRL-C = BREAK TO MONITOR 
 BPL RTS4B 
 STY KBDSTRB
 CPY #$93 CTRL-S = PAUSE 
 BNE CTLC
KYWAIT LDY PB0 F(S) ENTRY POINT
 BMI KYWT2
 LDY KBD
 BPL KYWAIT
 STY KBDSTRB
 DFB $2C
KYWT2 LDY #0 0 = OPEN APPLE PRESSED
CTLC CPY #$83
 BNE RTS4B
 JMP MONZ
RDKEY JMP (KSWL)
KEYIN LDY CH
 LDA (BASL),Y
 PHA
 AND #$3F INVERSE CURSOR
 STA (BASL),Y
 PLA
 BIT KBD
 BPL KEYIN
 ORA #$80
 STA (BASL),Y
 LDA KBD
 BIT KBDSTRB
 RTS 
NOTCR LDA IN,X
 JSR COUT 
 CMP #$88
 BEQ BCKSPC
 CPX #34 BEEP ON LAST 4 CHAR. 
 BCC NOTCR1
 JSR BELL
NOTCR1 INX 
 CPX #38 38 CHARACTERS ALLOWED 
 BCC NXTCHAR 
 LDA #$DC
 JSR COUT 
GETLNZ JSR CROUT
 LDA PROMPT
 JSR COUT 
 LDX #$01
BCKSPC TXA 
 BEQ GETLNZ
 DEX 
NXTCHAR JSR RDKEY
 CMP #$95 
 BEQ NXTCHAR IGNORE '->'
 CMP #$FF
 BNE NOTDEL
 LDA #$88 DELETE KEY = BACKSPACE
NOTDEL CMP #$88
 BNE CAPTST
 PHA
 JSR COUT BACKSPACE
 JSR OUTSP DELETE CHARACTER
 PLA  BACKSPACE
CAPTST CMP #$E0
 BCC ADDINP
 AND #$DF
ADDINP STA IN,X
 CMP #$8D
 BNE NOTCR
CROUT LDA #$8D
 BNE COUT
HOME LDA #$8C
 BNE COUT
OUTSP LDA #$A0
 BNE COUT
PRA1 LDY A1H
 LDX A1L
PRYX2 JSR CROUT
 JSR PRNTYX
 LDY #$00
 LDA #$AD
 JMP COUT
MOD8CHK LDA A1L
 AND #$07
 BNE DATAOUT
XAM JSR PRA1 F(.) A1.A2 
DATAOUT JSR OUTSP 
 LDA A1H SEE IF ZERO PAGE
 BNE XAM2
 LDA A1L
 SEC
 SBC #PCL
 BCC XAM2 TAKEN IF A1L < PCL
 TAX  OTHERWISE GET FROM ZBUF
 LDA ZBUF,X
 DFB $2C SKIP NEXT INSTRUCTION
XAM2 LDA (A1L),Y
 JSR PRBYTE
 JSR NXTA1
 BCC MOD8CHK CARRY CLEAR IF A1<A2 
 RTS 
XAMPM LSR A
 BCC XAM
 LSR A
 LSR A
 LDA A1L 16 BIT ADD. OR SUB. 
 BCC ADD
 SBC A2L SUBTRACT A2 FROM A1 
 STA A1L RESULT IN A1 
 LDA A1H
 SBC A2H
 STA A1H
 JMP PRANS 
ADD ADC A2L ADD A1 AND A2 
 STA A1L RESULT IN A1 
 LDA A1H
 ADC A2H
 STA A1H
PRANS JSR OUTEQ 
 LDA A1H
 JSR PRBYTE
 LDA A1L
PRBYTE PHA 
 LSR A
 LSR A
 LSR A
 LSR A
 JSR PRHEXZ
 PLA 
 AND #$0F
PRHEXZ ORA #$B0
 CMP #$BA
 BCC COUT
 ADC #$06
COUT CMP #$8D
 BNE COUTZ
 STY YSAV1 
 LDY TFLG LOCK OUT CTRL-C BREAK
 BNE NOCTRLC DURING TRACE PC PRINT
 JSR CTRLC
NOCTRLC LDY YSAV1
COUTZ JMP (CSWL)
COUT40 STY YSAV1
 PHA
 CMP #$8C CHECK FOR HOME (CTRL-L)
 BNE COUT40A
 JSR HOME40
 JMP COUT40B
COUT40A JSR VIDOUT
COUT40B PLA
 LDY YSAV1
 RTS 
OUTEQ LDA #$BD
 BNE COUT
BL1 DEC YSAV F(CR) CALLS HERE
 BEQ RTS5 CR ONLY SO IGNORE 
BLANK DEX 
 BNE SETMDZ
 CMP #$BA
 BNE XAMPM
 STA MODE F(:) 
 LDA A2L
 STA (A3L),Y Y=0
 INC A5L HSF BYTE COUNT
 INC A3L
 BNE RTS5
 INC A3H
RTS5 RTS 
SETMODE LDA #0
 STA A5L CLEAR HSF BYTE COUNT
 LDY YSAV 
 LDA IN-1,Y EQUALS :,+,- OR . MODE 
SETMDZ STA MODE
 RTS 
LT LDX #$01 F(<) 
LT2 LDA A2L,X COPY A2 TO A4 
 STA A4L,X
 DEX 
 BPL LT2
 INX  BRKADDRH = 0
 STX BRKADDR+1 FLAGS BREAKPOINT GIVEN
 RTS 
MOVE LDA (A1L),Y F(M) A4<A1.A2M 
 STA (A4L),Y
 JSR NXTA4 INCREMENTS A1 AND A4 
 BCC MOVE CARRY CLEAR IF A1<A2 
 RTS 
VFY LDA (A1L),Y F(V) A4<A1.A2V
 CMP (A4L),Y
 BEQ VFYOK
 JSR PRA1
 LDA (A1L),Y
 JSR PRBYTE
 JSR OUTSP
 LDA #$A8 '('
 JSR COUT
 LDA (A4L),Y
 JSR PRBYTE
 LDA #$A9 ')'
 JSR COUT
 JSR LWAIT
VFYOK JSR NXTA4
 BCC VFY
 RTS
LIST JSR A1PC F(L) 
 JSR SETBREAK NNNN<300L WILL STOP LIST
LIST2 JSR INSTDSP AT NNNN
 JSR PCADJ  
 JSR LWAIT
 SEC  COMPARE PC TO BRKADDR
 LDA PCL
 SBC BRKADDR
 STA A5L TEMP USE
 LDA PCH
 SBC BRKADDR+1
 ORA A5L
 BCC LIST2 TAKEN IF PC < BRKADDR
 RTS
A1PC TXA  X=0 IF NO # GIVEN
 BEQ RTS6
A1PCLP LDA A1L,X X=1
 STA PCL,X
 DEX 
 BPL A1PCLP
 LDA #0
 STA JFLG
RTS6 RTS 
SETPRNT JSR CROUT F(P)
 LDA SWITCH2
 LDY MCSWL SAVE CURRENT MONITOR
 LDA MCSWH OUTPUT HOOK.
 STY CSWL
 STA CSWH
 LDY #>PRINIT SIMULATE PR#1
 LDA #<PRINIT
 STY MCSWL
 STA MCSWH
 JSR PRINIT
 LDY MCSWL RESTORE OLD MONITOR
 LDA CSWL OUTPUT HOOK AND SET
 STY CSWL COUT TO PRINTER BY
 STA MCSWL EXCHANGING CSW'S.
 LDY MCSWH
 LDA CSWH
 STY CSWH 
 STA MCSWH
 RTS
CRMON JSR BL1 F(CR) 
 JMP MONZ
GO JSR A1PC F(G)
 LDA BRKADDR+1 'GO' WITH NO BREAKPOINT
 BEQ GOBREAK GIVEN EXECUTED AS 'JUMP'
 JMP TRCPCG WITH NO PARM BYTES.
GOBREAK LDY #2 'GO' WITH BRKPOINT GIVEN
LOADRT LDA (A4L),Y SAVES 3 BYTES FROM BREAK
 STA XQT+3,Y ADDR (XQT+3 = TEMP) AND
 LDA RTENTRY,Y PUTS JSR REENTER IN ITS
 STA (A4L),Y PLACE WHICH WILL CAUSE
 LDA INITBL3,Y A REAL TIME RE-ENTRY TO
 STA XQT,Y TO ANALYST.
 DEY
 BPL LOADRT
 JSR SAVEPC PUT RUN ADDR INTO PCREG
 LDX SPNT
 TXS
XQJ LDA STATUS RESTORE REGS
 PHA
 JSR ZSWAPT GET PROGRAM 0 PAGE 
 LDA ACC
 LDX XREG
 LDY YREG
 PLP
 JMP XQT EXECUTE
INITBL3 JMP (PCREG)
RTENTRY JSR WARMV DUMMY STATEMENT.
REENTER JSR SAVE REAL-TIME RE-ENTRY
 JSR ZSWAPE WHICH IS CALLED AS
 PLA  A SUBROUTINE WITH PLA
 SEC  PLA TO SET PC FROM
 SBC #2 CALLER ADDRESS. RESTORES
 STA PCL ORIGINAL 3 BYTES TO BREAK
 PLA  ADDRESS.
 SBC #0
 STA PCH
 TSX
 STX SPNT
 LDY #2
RTREST LDA XQT+3,Y
 STA (PCL),Y
 DEY
 BPL RTREST
 JSR SAVEPC
 JMP MONZ
SAVE PHP 
 STA ACC 
 PLA 
 STA STATUS 
 CLD
 STX XREG
 STY YREG
ZSWAPT LDA ZFLG SWAP ALL IF ZFLG = $AA
 CMP #$AA ELSE SWAP ONLY PCL-BASH
 BNE ZSWAPS
ZSWAP LDX #BAS2H-PCL SWAP ALL
 DFB $2C
ZSWAPS LDX #BASH-PCL
ZSWP1 LDA PCL,X
 LDY ZBUF,X
 STY PCL,X
 STA ZBUF,X
 DEX
 BPL ZSWP1 
ZSWAPRTS RTS
ZSWAPE LDA ZFLG SWAP ZFLG-BAS2H IF ID
 CMP #$AA PRESENT.
 BEQ ZSWAPRTS
 JSR ZSWAP SWAP ZFLG-BAS2H ONLY.
 BMI ZSWAPS ALWAYS TAKEN
RESET CLD 
 LDX #STKLMT SET ANALYST STACK UPPER
 TXS  LIMIT
 LDA ZFLG
 CMP #$AA
 BEQ RST2 IF ID NOT PRESENT 
 JSR ZSWAP THEN SWAP 0 PAGE 
 LDA #$AA & SET ID --> ZFLG:AA 
 STA ZFLG
RST2 JSR TEXT PRIMARY TEXT MODE
 LDA #$00
 STA TFLG
 STA JFLG
 STA ROMFLG NOTRACE JSR ROM $D000-FFFF
 JSR PRTITLE
 JMP MONZ
ERRMON LDA ERRFLG IF ERROR, 'ERR' ON BRK 
 BEQ MON
PRERR LDX #4 PRINT 'ERR' 
ERROUT LDA ERRMSG,X
 JSR COUT 
 DEX
 BPL ERROUT
MON CLD 
 JSR BELL
MONZ LDX #STKLMT SET STACK UPPER LIMIT
 TXS
 DEC BRKADDR+1 INSURE BRKPOINT CLEARED
 JSR ZSWAPE MAKE SURE ANALYST 0 PAGE.
 JSR CHKVID MATCH HOOKS W/DISPLAY MODE
 JSR STPRMPT
 JSR GETLNZ 
 JSR ZMODE
 STY ERRFLG CLEAR ERROR FLAG (Y=0) 
 STY DSPTOP DISPLAY AT TOP
NXTITM JSR GETNUM HANDLE HEX DIGS TO 1ST 
 STY YSAV NON-HEX CHAR+1 (Y=INDX)
 LDY #SUBTBL-CHRTBL 
CHRSRCH DEY  ACC = F(ACC) 
 BMI PRERR
 CMP CHRTBL,Y
 BNE CHRSRCH
 JSR TOSUB
NEXTITM LDY YSAV
 JMP NXTITM
DIG LDX #$03 HEX DIGIT NOW IN ACC LO 
 ASL A NIBBLE. KEYS 0-9=00-09 
 ASL A KEYS A-F=FA-FF. MOVE 
 ASL A LO NIBBLE TO HI NIBBLE 
 ASL A
NXTBIT ASL A 4 BIT HEX DIG. INTO A2L 
 ROL A2L A2L TO A2H 
 ROL A2H
 DEX 
 BPL NXTBIT
NXTBAS LDA MODE
 BNE NXTBS2 IF MODE=0 COPY 
 LDA A2H,X A2 TO A1 & A3
 STA A1H,X
 STA A3H,X
NXTBS2 INX 
 BEQ NXTBAS
 BNE NXTCHR
GETNUM LDX #0
 LDA ZFLG SET A2 = 0 ONLY IF
 CMP #$AA NOT IN DEFERRED STEP
 BNE NXTCHR MODE.
 STX A2L
 STX A2H
NXTCHR LDA IN,Y F(ACC) = ACC EOR $B0
 INY  ADC $88 (CARRY SET)
 EOR #$B0 KEYS 0-9=$00-09 
 CMP #$0A
 BCC DIG TAKEN IF KEYS 0-9 
 ADC #$88 KEYS A-F=$FA-FF 
 CMP #$FA 
 BCS DIG TAKEN IF KEYS A-F 
 RTS 
TOSUB TYA  # OF FUNCTION (START=0)
 ASL A MULT BY 2 
 TAY
 LDA SUBTBL+1,Y 
 PHA
 LDA SUBTBL,Y
 PHA 
 LDA MODE OLD MODE FOR F(CR)&F( ) 
ZMODE LDY #$00
 STY MODE
 RTS  RTS TO SUBROUTINE 
EXECJSR LDA JFLG F(J) 
 BNE GOJSR
ERRJ JMP PRERR F(J) ATTEMPTED W/O JSR!
GOJSR LDY YSAV GET # OF PARM BYTES
 JSR GETNUM
 DEY
 STY YSAV
 LDA A2H
 BNE ERRJ
 LDA A2L
 CMP #10
 BCS ERRJ ONLY 9 PARM BYTES MAX
 TAY  SAVE BYTE COUNT 
GOPC LDX #14 
XQINIT2 LDA INITBL2,X FILL DUMMY BLOCK
 STA XQT,X
 DEX
 BPL XQINIT2
 LDA PCL MOVE JSR ADDR TO XQT
XQLOC1 STA XQT+1
 LDA PCH
 STA XQT+2
 LDX SPNT SET PC = PARM LIST - 1 
 INX
 LDA STACK,X
 STA PCL
 INX
 LDA STACK,X
 STA PCH
 STX SPNT
 TYA  GET PARM BYTES 
 TAX
 BEQ MVPRM1 NO PARM BYTES TO MOVE
MOVPARM LDA (PCL),Y MOVE PARM LIST TO DUMMY
 STA XQT+2,Y 
 DEY 
 BNE MOVPARM
MVPRM1 INX 
 TXA  ADJ PC TO POINT TO INST 
 CLC  FOLLOWING PARM LIST
 JSR PCADJAP
 JMP XQJ EXECUTE JSR IMMED. MODE
INITBL2 JSR $0000 DUMMY BLOCK FOR F(J)
 NOP  9 NOP'S FOR PARM BYTES
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 JMP JRTS
JRTS JSR SAVE
 JSR CHKVID
 LDA JFLG
 BEQ JRTS3 DURING 'G0' W/O BREAK
 LDA #0
 STA JFLG
 LDA TFLG
 BEQ JRTS2 DURING 'STEP'
 JMP TRACE5 DURING TRACE IMMEDIATE
JRTS2 DEC DSPTOP UPDATE REGDSP AFTER JSR.
JRTSX JSR CLEARDSP 'SKIP' ENTERS HERE
 JMP NXTPC
JRTS3 JMP NEXTITM
 SKP 1 
*** THE MINI-ASSEMBLER ***
 SKP 1 
RELADR SBC #$81
 LSR A
 BNE PCERR
 LDY A2H
 LDX A2L
 BNE RELADJ
 DEY 
RELADJ DEX 
 TXA 
 CLC 
 SBC PCL
 STA A2L
 BPL RELADJ2
 INY 
RELADJ2 TYA 
 SBC PCH
PCERR BNE ERRAT
POKEAT LDY LENGTH
POKE LDX A1H,Y
 TXA 
 STA (PCL),Y
 DEY 
 BPL POKE
 JSR UP
 JSR UP
 JSR INSTDSP
 JSR CLREOL
 JSR PCADJ
 JMP MINI
DSS LDA A1H
 JSR INSDS2
 TAX 
 LDA MNEMR,X
 CMP A4L
 BNE NXOPC
 LDA MNEML,X
 CMP A4H
 BNE NXOPC
 LDA A5L
 LDY FORMAT
 CPY #$9D
 BEQ RELADR
 CMP FORMAT
 BEQ POKEAT
NXOPC DEC A1H
 BNE DSS
 INC A5L
 DEC YSAV1
 BEQ DSS
ERRAT LDY YSAV
ERROR TYA 
 TAX 
 JSR PRBLNK
 LDA #$DE
 JSR COUT
 JSR BELL
MINI LDA #$A1
 STA PROMPT
 JSR GETLNZ
 JSR ZMODE
 LDA IN
 CMP #$A0
 BEQ RDMNEM
 TXA
 BNE MINI2
 STA YSAV <CR> ALONE EXITS
 JMP STPRMPT VIA NEXTITM
MINI2 JSR GETNUM
 CMP #$93 F(:) 
A1TOPC BNE ERROR
 TXA 
 BEQ ERROR
 JSR A1PCLP
RDMNEM LDA #$03 INDEX FOR 3 CHAR MNEM 
 STA A1H
RDMNEM2 JSR CHARIN
 ASL A
 SBC #$BE
 CMP #$C2 LESS THAN 'A' 
 BCC ERROR NOT ASC LETTER SO ERR 
 ASL A
 ASL A
 LDX #$04 INDEX FOR 5 BITS 
RDMNEM3 ASL A MOVE 5 BIT LETTER CODE 
 ROL A4L (* 3 LETTERS) INTO A4. 
 ROL A4H 26 LETTERS REQ. 5 BITS 
 DEX 
 BPL RDMNEM3
 DEC A1H
 BEQ RDMNEM3
 BPL RDMNEM2
 LDX #$05 INDEX FOR 6 FORMAT BITS 
RDFMT JSR CHARIN
 STY YSAV
 CMP CHAR1,X
 BNE RDFMT2
 JSR CHARIN
 CMP CHAR2,X
 BEQ RDADDR
 LDA CHAR2,X
 BEQ RDFMT3
 CMP #$A4
 BEQ RDFMT3
 LDY YSAV
RDFMT2 CLC 
RDFMT3 DEY 
RDADDR ROL A5L
 CPX #$03
 BNE RDADDR3
 JSR GETNUM
 LDA A2H
 BEQ RDADDR2
 INX 
RDADDR2 STX YSAV1
 LDX #$03
 DEY 
RDADDR3 STX A1H
 DEX 
 BPL RDFMT
 LDA A5L
 ASL A
 ASL A
 ORA YSAV1
 CMP #$20
 BCS RDADDR4
 LDX YSAV1
 BEQ RDADDR4
 ORA #$80
RDADDR4 STA A5L
 STY YSAV
 LDA IN,Y
 CMP #$8D
 BEQ DISAS
 JMP A1TOPC
DISAS JMP DSS
CHARIN LDA IN,Y
 INY 
 CMP #$A0
 BEQ CHARIN
 RTS 
MOD8CK LDA A1L
 AND #$07
 BNE ASCOUT
ASC JSR PRA1 F(")
ASCOUT JSR OUTSP 
 LDA (A1L),Y
 ORA #$80
 CMP #$A0
 BCS PRASC TAKEN IF NORM. OR LCASE
 LDA #$A0 SPACE FOR CTRL OR INV   
PRASC JSR COUT
 JSR NXTA1
 BCC MOD8CK
 RTS
FIND LDA #$FF F(CTRL-F) A4<A1 CTRL-F
 STA A1L HEX SEQUENCE FINDER
 STA A4L
 DEC A4H
 LDX A5L
 STX XQT BYTE COUNT
 DEX
 BNE FXEND
 LDA A1H
 CMP #$FF
 BNE FXEND
 DEC A1L
FXEND DEC A1L
 DEX
 BNE FXEND
INCBAS INC A4L
 BNE TESTEND
 INC A4H
 LDA A4H
 CMP #$C0
 BNE TESTEND
 LDA #$C1
 STA A4H
TESTEND LDA A1H
 CMP A4H
 BCC DONE
 BEQ TESTLO
 BNE SETTMP
TESTLO LDA A1L
 CMP A4L
 BCC DONE
SETTMP LDA A4H
 STA A5H
 LDA A4L
 CLC
 ADC XQT
 STA A5L
 BCC SETX
 INC A5H
SETX LDX XQT
 INX
CHGTMP SEC
 LDA A5L
 SBC #$01
 STA A5L
 BCS CMPNUM
 DEC A5H
CMPNUM LDY #$00
 LDA (A5L),Y
 DEX
 CMP XQT,X
 BNE INCBAS
 LDA A5L
 CMP A4L
 BNE CHGTMP
 LDX A4L
 LDA A4H
 JSR PRNTAX
 JSR OUTSP 
 CLV
 BVC INCBAS
DONE JMP CROUT 
RELOC LDY #0 F(R)
 LDA (A1L),Y MAKE SURE DESTINATION
 EOR #$FF IS R/W ENABLED.
 STA (A1L),Y
 CMP (A1L),Y
 BNE DONE
 LDA A1H
 STA A4H
 LDA A4H
 STA PCH
 STA A3H
 LDA #0 PAGE BOUNDARY ONLY
 STA A4L
 STA PCL
 STA A3L
 LDA SUMLOC+2
 STA A1H
 STA A5L
 LDA SUMLOC+1
 STA A1L
 LDA CSUMLOC+2
 STA A2H
 LDA CSUMLOC+1
 STA A2L
 LDA #$20 WILL NEED NEW CHECKSUM
 STA GETSUM
 LDA A1H CALC DIFFERENCE BETWEEN
 SEC  OLD & NEW ORG
 SBC A4H
 STA A5H
 LDA #ERRMSG-SUBTBL
 LSR A DIVIDE BY 2
 TAY  # OF WORDS
 LDX #$FF
RELOC2 INX  CONVERT SUBTBL WORDS
 INX
 LDA SUBTBL,X
 SEC
 SBC A5H
 STA SUBTBL,X
 DEY
 BNE RELOC2
 JSR MOVE NEW ORG<GETSUM.ENDMAIN
 INC A2H
 LDA TITLLOC+1 END OF STATIC PGM AREA
 STA A4L
 LDA TITLLOC+2
 SEC
 SBC A5H
 STA A4H
RELOC3 LDX #0
 JSR INSDST
 LDY LENGTH
 CPY #2 3-BYTE INSTRUCTION ?
 BCC NABS
 LDX #0
 LDA (PCL,X)
 CMP #$2C
 BEQ NABS IGNORE BIT ABSOLUTE
 LDA (PCL),Y Y=2
 LDX A2H IF OLD ENDMAIN WAS $FFNN
 BEQ CHKLO THEN DON'T CHECK ABOVE !!
 CMP A2H SEE IF WITHIN OLD
 BCS NABS START-ENDMAIN
CHKLO CMP A5L
 BCC NABS
 SBC A5H CONVERT TO NEW ADDR
 STA (PCL),Y
NABS JSR PCADJ
 CMP A4L SEE IF PC < NEW END OF
 TYA  STATIC PGM AREA
 SBC A4H
 BCC RELOC3
 JMP (A3L) RUN NEW ORG
SETDOS TXA  F(/) SET OR PRINT DOS
 BNE SETDS2 SUBROUTINE TO JSR IMMED.
 LDA DOSCALL+1 '/' ALONE PRINTS ADDRESS
 LDX DOSCALL
 JSR PRNTAX
 JMP CROUT
SETDS2 LDA A1L NNNN/ COPIES NNNN INTO
 STA DOSCALL DOSCALL
 LDA A1H
 STA DOSCALL+1
 RTS
SETVID LDY YSAV F(@)
 LDA IN,Y
 INC YSAV
 CMP #$B4 '4'
 BEQ INIT40
 CMP #$B8 '8'
 BEQ INIT80
 DEC YSAV @ ALONE
TEXT LDA MCSWH SET 40 OR 80 COL TEXT
 CMP #$C3
 BEQ INIT80
INIT40 LDA #<MKEYIN EXECUTE PR#0 TO KEEP
 LDY #>MKEYIN PROPER DOS HOOKS.
 STA MKSWH
 STY MKSWL
 LDA #<MVIDOUT
 LDY #>MVIDOUT
 STA MCSWH
 STY MCSWL
 LDA #40
 STA WNDWDTH
 JSR IN40
 STA CLR80VID
 JSR HOME40
 STA LOWSCR
 STA TXTSET
 RTS
STPRMPT LDA #$A3
 STA PROMPT
 RTS
IN40 LDX #4
MOVE40 LDA HOOK40-1,X
 STA CSWL-1,X
 DEX
 BNE MOVE40
 STX FLG8 SET = 0
RTS7 RTS
CHKVID LDA MCSWH RESET 40/80 COL IF NEEDED
 CMP #$C3
 PHP
 LDA FLG8
 BMI CHK80
 PLP
 BNE RTS7
 BEQ IN80 40 -> 80
CHK80 PLP
 BNE IN40 80 -> 40
 BEQ RTS7
 SKP 1
*** 80 COLUMN DRIVER ROUTINE ***
 SKP 1
INIT80 JSR HOME
 STA CLR80ROM ENABLES $C300 ROM
 JSR PR3
IN80 LDX #3
MOVE80 LDA MCSWL,X
 STA CSWL8,X
 LDA HOOK80,X
 STA CSWL,X
 DEX
 BPL MOVE80
 STX FLG8 SET = FF
 RTS
COUT80 JSR EXCHV
 JSR COUTZ80
 JMP EXCHV
COUTZ80 JMP (CSWL8)
KEYIN80 JSR EXCHV
 JSR KEY80
 JMP EXCHV
KEY80 JMP (KSWL8)
EXCHV PHA
 TXA
 PHA
 TYA
 PHA
 LDY #1
EXCH2 LDA MCH,Y EXCHANGE CH,CV AND BASE
 LDX CH,Y ADDRESS BETWEEN ANALYST
 STA CH,Y AND 80 COL ROM COUT.
 STX MCH,Y
 LDA MBASL,Y
 LDX BASL,Y
 STA BASL,Y
 STX MBASL,Y
 DEY
 BPL EXCH2
 PLA
 TAY
 PLA
 TAX
 PLA
 RTS
PRTITLE LDX #$00 PRINT TITLE 
TITLLOC LDA TITLE,X
 BEQ PRADDR 
 JSR COUT
 INX
 BNE TITLLOC 
PRADDR LDA SUMLOC+2 PRINT ORIGIN ADDRESS
 JSR PRBYTE
 LDA #0
 JSR PRBYTE
 JSR CROUT
 JSR DOSUM
 LDA A3L
 CMP CHKSUM
 BNE ERRSUM
 LDA A3H
 CMP CHKSUM+1 
 BNE ERRSUM
 JSR CROUT
 LDA #$CF PRINT 'OK' 
 JSR COUT
 LDA #$CB
 JSR COUT
 JMP CROUT
ERRSUM JMP PRERR 
DOSUM LDA STARTLOC
 STA A1L
 LDA STARTLOC+1
 STA A1H
 LDA ENDLOC 
 STA A2L
 LDA ENDLOC+1 
 STA A2H
 LDX #0
 STX A3L
 STX A3H
GETBYT CLC
 LDA (A1L,X) 
 ADC A3L
 STA A3L
 LDA #0
 ADC A3H
 STA A3H
 JSR NXTA1
 BCC GETBYT
 RTS
INITSUM JSR DOSUM CHKSUM OF START-ENDMAIN 
 LDA A3L
 STA CHKSUM
 LDA A3H
CSUMLOC STA CHKSUM+1
 RTS
 SKP 1
*** PROGRAM DATA AREA ***
 SKP 1
TITLE DFB $8D
 ASC "ANALYST 64"
 DFB $8D TITLE MARKS START OF PDA
 ASC "ORG = $"
 DFB $00 
FMT2 DFB 0,33,129,130,90,73,89,77
 DFB 145,146,134,74,133,157
MNEML DFB 28,138
 DFB 28,35,93,139,27,161,157,138
 DFB 29,35,157,139,29,161,28,41
 DFB 25,174,105,168,25,35,36,83
 DFB 27,35,36,83,25,161,173,26
 DFB 165,91,165,172,139,138,174,174
 DFB 168,173,41,138,124,139,21,156
 DFB 109,156,165,105,41,83,132,19
 DFB 52,17,165,105,35,160
MNEMR DFB 216,98
 DFB 90,72,38,98,148,136,84,68
 DFB 200,84,104,68,232,148,196,180
 DFB 8,132,116,180,40,110,116,244
 DFB 204,74,114,242,164,138,6,170
 DFB 118,162,116,198,116,116,68,104
 DFB 178,50,178,114,34,114,26,26
 DFB 38,38,114,114,136,200,196,202
 DFB 38,72,68,68,162,200
FMT1 DFB 240,34,0,51,93,130,0,147
 DFB 243,34,0,51,93,136,0,153
 DFB 240,47,0,51,93,143,0,159
 DFB 240,34,0,59,93,136,0,148
 DFB 253,34,0,51,93,200,0,147
 DFB 17,34,0,51,93,200,0,169
 DFB 241,34,0,51,93,143,0,159
 DFB 241,34,0,51,93,143,0,159
 DFB 38,49,135,154
OPC65C DFB 18,50,82,114
 DFB 146,178,210,242,58,26,137,28
 DFB 20,122,90,156,100,158,116,124
 DFB 60,52
 DFB 76,164,172,180,188,196,204,228
 DFB 236
REPL65C DFB 17,49,81,113,145,177
 DFB 209,241,194,226,52,164,172,196
 DFB 228,92,92,92,92,124,60,52
 DFB 124,160,160,160,160,192,192
 DFB 224,224
CHAR1 DFB 172,169,172,163,168,164
CHAR2 DFB 217,0,216,164,164,0
CHAR3 ASC "CZIDB-VN" 
RTBL ASC "AXY" 
CHRTBL DFB 152,249,3,236  
 DFB 166,164,6,149,5
 DFB 0,147,2,167,198,153
 DFB 155,154,239,233,1,191
 DFB 168,237,158,235,197
SUBTBL DW PRTITLE-1 F(?) DO CHCKSUM OF MAIN
 DW SETVID-1 F(@) SWITCH 40/80 COL
 DW EXECJSR-1 F(J) EXECUTE JSR  
 DW STEP-1 F(S) STEP 
 DW SETMODE-1 F(-) 16 BIT SUBTRACTION 
 DW SETMODE-1 F(+) 16 BIT ADDITION 
 DW MOVE-1 F(M) MOVE 
 DW LT-1 F(<) COPY A2 TO A4 & A5 
 DW LIST-1 F(L) LIST DISASSEMBLY
 DW GO-1 F(G) GO 
 DW SETMODE-1 F(:) STORE 
 DW SETREG-1 F(I) SET INTERNAL PC/REG
 DW SETMODE-1 F(.) XAM 
 DW CRMON-1 F(CR) HANDLE CR 
 DW BLANK-1 F( ) HANDLE SPACES 
 DW ASC-1 F(") DUMP IN ASCII 
 DW MINI-1 F(!) MINI-ASSEMBLER 
 DW VFY-1 F(V) VERIFY
 DW SETPRNT-1 F(P) TO PRINTER
 DW LOAD-1 F(H) LOAD FOR HSF
 DW FIND-1 F(CTRL-F) HEX SEQ. FIND
 DW SETDOS-1 F(/) SET DOS CALL JSR #.
 DW TRACE-1 F(T) TRACE
 DW BINARY-1 F(%) VALUE IN BINARY
 DW RELOC-1 F(R) RELOCATOR
 DW CRMON-1 HANDLE CTRL-L AS CR
HOOK40 DW COUT40
 DW KEYIN
HOOK80 DW COUT80
 DW KEYIN80
STARTLOC DW START
ENDLOC DW ENDMAIN
ERRMSG DFB $8D MARKS END OF WORDS
 ASC 'RRE'
 DFB $8D
ENDMAIN DFB $00 = END OF STATIC PGM AREA
 SKP 1
* DYNAMIC PROGRAM AREA *
 SKP 1
CSWL DS 1 ADDR. OF OUTPUT ROUTINE 
CSWH DS 1
KSWL DS 2 ADDR. OF INPUT ROUTINE
CSWL8 DS 2 DON'T CHANGE ORDER
KSWL8 DS 2 OF CSWL-KSWL8
TFLG DS 1 <> 0 = CANCEL COUT FOR TRC 
JFLG DS 1 SET TO ALLOW F(J) 
DOSCALL DS 2,255 SUBROUTINE TO JSR IMMED.
ERRFLG DS 1 SET FOR BAD OPCODE 
PCREG DS 2,0
ACC DFB 0 DON'T CHANGE ORDER 
XREG DFB 0 OF ACC TO SPNT
YREG DFB 0
STATUS DFB 0
SPNT DFB $F0
SREF DFB $F0 STACK REF SET BY TXS OPC
LMNEM DS 1
RMNEM DS 1
LENGTH DS 1
FORMAT DS 1
MODE DS 1
FLG8 DS 1 FF = 80 COL, 0 = 40 COL
PROMPT DS 1
CH DS 1
CV DS 1
DSPTOP DS 1 TOP OF DISPLAY FOR STEP
YSAV DS 1
YSAV1 DS 1
COUNTER DS 1
BRKADDR DS 2,255 BREAK FOR STEP,TRACE,LIST
ZBUF DS $100-PCL PAGE ZERO STORAGE BUFFER
CHKSUM DS 2 CHKSUM OF STATIC PROG. 
IN DS 38 KEYIN BUFFER.
FMTSAV EQU IN+12 TEMP STORAGE FOR INSTDSP
XQT DS 15 BUFFER FOR F(S,CTRL-F,J) 
ENDPGM EQU >*
FREESPC EQU $FF-ENDPGM
 DS FREESPC IF $NFFF SET <> 0 WILL TRC
ROMFLG DS 1 THRU JSR ROM $D000-FFFF.
