 LST OFF
 SBTL 
 MSB ON
 ORG $6000 
 SKP 1 
*********************************
*                               *
*       -< THE ANALYST >-       *
*                               *
*          VERSION 5.2          *
*                               *
*              BY               *
*                               *
*        LARRY A. GREENE        *
*                               *
*********************************
 SKP 1 
*** DESCRIPTION *** 
 SKP 1 
; THIS PROGRAM OPERATES INDEPENDENT OF ROM BUT HAS COM-
; MANDS SIMILAR TO THE BUILT IN MONITOR. THE TRACE AND
; STEP FUNCTIONS HAVE BEEN GREATLY ENHANCED TO DISPLAY
; STATUS REGISTER FLAGS AND SET A BREAK POINT. THE MINI
; ASSEMBLER HAS BEEN INCLUDED AS WELL AS A HEX SEQUENCE
; FINDER. 65C02 OPCODES ARE ALSO SUPPORTED. ZERO PAGE
; REFS ARE STORED IN A BUFFER WHICH AVOIDS CONFLICT WITH
; THE PROGRAM BEING TRACED. THIS PROGRAM USES THE BOTTOM
; 1/2 OF THE STACK ($100-180). TO USE DOS EXIT WITH
; CTRL-B AND RE-ENTER WITH &.
 SKP 1 
*** COMMANDS ***
 SKP 1 
; CTRL-A   DUMP MEMORY IN ASCII 
; CTRL-B   ENTER RESIDENT BASIC W/DOS. & TO RETURN
; CTRL-E   EXAMINE INTERNAL REGISTERS
; CTRL-F   FIND SPECIFIED HEX SEQUENCE DEFINED BY F(H)
;      G   GO EXECUTE IN IMMEDIATE MODE  
;      H   LOAD BYTES FOR HSF F(CTRL-F) BY USING H: 
;      I   CHANGE PC AND/OR INTERNAL A,X,Y,P,S REGISTERS
;      J   JUMP. EXECUTE JSR INSTRUCTION IN STEP MODE
; CTRL-L   CLEAR PRESENT SCREEN AND HOME CURSOR
;      L   LIST DISASSEMBLED INSTRUCTIONS
;      M   MOVE BLOCK OF MEMORY
;      P   SEND OUTPUT TO PRINTER
;      R   RELOCATE ANALYST TO NEW ADDRESS PAGE
;      S   ENTER STEP MODE. STEP INSTRUCTION
;      T   TRACE PROGRAM OR SET TRACE LIMIT
;      V   VERIFY TWO BLOCKS OF MEMORY
; CTRL-X   CANCEL LINE ENTRY
;      X   SKIP NEXT INSTRUCTION IN STEP MODE
;      %   PRINT ADDRESS DATA VALUE IN BINARY
;      ?   PRINT ORIGIN ADDRESS & DO INTERNAL CHECKSUM
;      @   SET TEXT 40/80 COL SCREEN
;      <   RANGE DELIMITER
;      .   RANGE DELIMITER
;      +   16 BIT ADDITION
;      -   16 BIT SUBTRACTION
;      :   STORE VALUE IN MEMORY
;      !   ENTER MINI-ASSEMBLER. "#" TO EXIT 
 SKP 1
*** OPERATING NOTES ***
 SKP 1 
; INPUT LINE LIMITED TO 38 CHARACTERS. BEEPS ON LAST 4.
 SKP 1
; HOME (CTRL-L) ACTS IMMEDIATELY. FOLLOW WITH <CR>.
 SKP 1
; FOR STEP TYPE 300S <CR> THEN S, OPEN-APPLE, SPACE, OR 
; J TO STEP EACH INSTRUCTION. S OR OPEN-APPLE TO STEP
; INTO JSR. J TO EXECUTE SUBROUTINE. X TO SKIP INSTRUC-
; TION. T TO ENTER TRACE. @ FOR TEXT. CTRL-C TO EXIT.
; @ WILL EXECUTE NEXT INSTRUCTION.
 SKP 1
; FOR TRACE USE FFFF<2000T WHERE FFFF DENOTES BRKPOINT.  
; PC PRINTED AT UPPER LEFT EVERY 256 LINES. OPEN APPLE
; ENTERS SLOW TRACE WITH PC PRINTED EACH LINE. CLOSED 
; APPLE EXITS TO STEP MODE. TRACE WILL EXECUTE  SUB-
; ROUTINES ABOVE PAGE# LIMIT IN IMMEDIATE MODE IF SET
; BY T:NN. WILL TRACE THRU RAM $D000-FFFF, HOWEVER.
; TO TRACE ALL SET T:00 WHICH IS DEFAULT VALUE.
; TRACE ACTIVITY INDICATED BY FLASHING $ OR # FOR JSR  
; IMMEDIATE MODE. BREAKPOINT ENTERS STEP MODE AND DOES
; EXECUTE BREAKPOINT INSTRUCTION.
 SKP 1
; FOR JUMP TYPE 'J5' WHERE 5 REPRESENTS # OF PARM BYTES 
; FOLLOWING JSR INSTRUCTION. J<CR> DEFAULTS TO 0. JUMP
; DURING STEP & TRACE IMMEDIATE HANDLE JSR $BF00 AS
; PRODOS MLI CALL WITH 3 PARM BYTES FOLLOWING. MUST USE
; 'J3' FROM COMMAND LINE. IF SUBROUTINE BEING 'JUMPED'
; CONTAINS A TXS INSTRUCTION, ANALYST WILL LOSE CONTROL!
; ALSO TRACE IMMEDIATE WILL NOT HANDLE A SUBROUTINE OTHER
; THAN $BF00 WITH PARM BYTES FOLLOWING!
 SKP 1
; STEP & TRACE BREAK FOR ILLEGAL OPCODES. PRINTS 'ERR' 
 SKP 1
; TO CHANGE PC AND/OR INTERNAL REGS TYPE 300I:AA XX 
; YY PP SS <CR>. PC ENTRY BEFORE I OPTIONAL.
 SKP 1 
; FOR HEX SEQUENCE FINDER TYPE H:N1 N2 N3... 
; 1000<2000 CTRL-F <CR>. 
 SKP 1 
; TO DUMP MEMORY IN ASCII USE 1000.2000 CTRL-A <CR>. 
 SKP 1
; TO PRINT ADDRESS BYTE IN BINARY TYPE 2000% <CR>.
 SKP 1
; TO SWITCH SCREENS TYPE @8,@4 OR @ FOR TEXT.
 SKP 1 
; TO RELOCATE TYPE NN00R <CR>. WILL ROUND OFF TO NEAREST
; PAGE BOUNDARY. DO NOT SET < $800! IF < 4K FROM OLD
; ORIGIN, WILL BE IGNORED. IF MOVED TO RAM CARD DO NOT
; CHANGE CARD R/W STATE!
 SKP 1
; DO NOT USE THE PRINTER WHEN THE ANALYST IS LOCATED
; ON THE RAM CARD. THE PRINTER WILL NOT INITIALIZE.
; ALSO RESET WILL NOT RETURN TO THE ANALYST LOCATED
; ON THE RAM CARD WITH 128K MACHINES.
 SKP 1
; & VECTOR $3F5 IS A WARMSTART RE-ENTRY WHICH CAN BE
; USED TO JMP INTO ANALYST FROM A RUNNING PROGRAM
; WITH ALL REGS PRESERVED.
 SKP 1
; THE ANALYST USES $C01F TO DETECT 80 COL MODE.
; THIS METHOD IS INVALID ON OLDER NON-IIE APPLES.
 SKP 1
; TO STEP AND TRACE AUX MEMORY, ANALYST SHOULD BE IN
; 80 COLUMN MODE.
 SKP 1
*** ROM ZERO PAGE EQUATES *** 
 SKP 1
WNDWDTH EQU $21
MCH EQU $24
MCV EQU $25
MCSWL EQU $36
MCSWH EQU $37
MKSWL EQU $38
MKSWH EQU $39
MPCL EQU $3A
MPCH EQU $3B
MA1L EQU $3C
MA1H EQU $3D
MA2L EQU $3E
MA2H EQU $3F
MA4L EQU $42
MA4H EQU $43
MACC EQU $45
MXREG EQU $46
MYREG EQU $47
MSTATUS EQU $48
MSPNT EQU $49
RNDL EQU $4E 
SPDBYT EQU $F1 APPLESOFT SPEED=
 SKP 1
*** ANALYST EQUATES ***
 SKP 1
STKLMT EQU $80 TOP OF STACK (IMMEDIATE)
ZFLG EQU $EE 2 BYTE ID ($D5 $AA)
A1L EQU $F0 A1L-A5H MUST BE IN ORDER
A1H EQU $F1 FOR MINI-ASSEMBLER 
A2L EQU $F2 
A2H EQU $F3 
A3L EQU $F4 
A3H EQU $F5 
A4L EQU $F6 
A4H EQU $F7 
A5L EQU $F8 
A5H EQU $F9 
PCL EQU $FA
PCH EQU $FB
BASL EQU $FC
BASH EQU $FD 
BAS2L EQU $FE
BAS2H EQU $FF LABEL MARKS END OF PAGE 0.
STACK EQU $0100
 SKP 1 
*** DYNAMIC PROGRAM AREA *** 
 SKP 1
* $0100 CANNOT BE USED OR PRODOS WILL NOT BRUN ANALYST
 SKP 1
CSWL EQU $0101 ADDR. OF OUTPUT ROUTINE 
CSWH EQU $0102
KSWL EQU $0103 ADDR. OF INPUT ROUTINE
CSWL8 EQU $0105 DON'T CHANGE ORDER
KSWL8 EQU $0107 OF CSWL-KSWL8
LMNEM EQU $0109
RMNEM EQU $010A
LENGTH EQU $010B
MODE EQU $010C
FORMAT EQU $010D
FUNNY EQU $010E RESET VECTOR FUNNY BYTE
ERRFLG EQU $010F SET FOR BAD OPCODE 
XFLG EQU $0110 1 = SKIP INSTRUCTION
TFLG EQU $0111 1 = CANCEL COUT FOR TRC 
JFLG EQU $0112 SET TO ALLOW F(J) 
FLG8 EQU $0113 FF = 80 COL, 0 = 40 COL
PROMPT EQU $0114
CH EQU $0115
CV EQU $0116
ACC EQU $0117 DON'T CHANGE ORDER 
XREG EQU $0118 OF ACC TO SPNT
YREG EQU $0119
STATUS EQU $011A
SPNT EQU $011B
YSAV EQU $011C
YSAV1 EQU $011D
TLIMIT EQU $011E PAGE# OF TRACE LIMIT
XQT EQU $011F BUFFER FOR F(S,CTRL-F,J) 
ZBUF EQU $012E PAGE ZERO STORAGE BUFFER
CHKSUM EQU $0140 CHKSUM OF STATIC PROG. 
IN EQU $0142 KEYIN BUFFER. IN+8 TEMP.
DOSV EQU $03D0 DOS BASIC WARM ENTRY
BRKV EQU $03F0 BREAK VECTOR
SOFTEV EQU $03F2 RESET VECTOR 
AMPERV EQU $03F5 ANALYST WARMSTART RE-ENTRY
MLI EQU $BF00 PRODOS INTERFACE
 SKP 1
*** ROM EQUATES ***
 SKP 1
KBD EQU $C000
CLR80COL EQU $C000 ENABLE PAGE2 DISPLAY
MAINRD EQU $C002
MAINWR EQU $C004
CLRIOROM EQU $C006
MAINZP EQU $C008
AUXZP EQU $C009
CLR80ROM EQU $C00A
CLR80VID EQU $C00C
CLRCHAR2 EQU $C00E
KBDSTRB EQU $C010
RDAUXZP EQU $C016 BMI IF AUXZP
RD80VID EQU $C01F BMI IF 80 COL MODE
SPKR EQU $C030
TXTSET EQU $C051
LOWSCR EQU $C054
SETAN0 EQU $C058
PB0 EQU $C061 OPEN APPLE KEY
PB1 EQU $C062 CLOSED APPLE KEY
SWITCH2 EQU $C082
SWITCH3 EQU $C083
PRINIT EQU $C100 PRINTER IN SLOT 1
PR3 EQU $C300
AUXMOVE EQU $C311
IDROM EQU $E000 = $4C IF ROM PRESENT
MKEYIN EQU $FD1B
MVIDOUT EQU $FDF0
RESET EQU $FFFC RESET VECTOR IN RAMCARD 
IRQ EQU $FFFE BREAK VECTOR IN RAMCARD
 SKP 3 
GETSUM JSR INITSUM CREATE CHECKSUM OF MAIN 
 LDA #$2C WHEN FIRST BRUN
SUMLOC STA GETSUM DISABLE CHECKSUM
 LDA SUMLOC+1 COPY GETSUM - ENDMAIN
 STA MA1L INTO AUX AT SAME ADDR
 STA MA4L
 LDA SUMLOC+2
 STA MA1H
 STA MA4H
 LDA ENDLOC
 STA MA2L
 LDA ENDLOC+1
 STA MA2H
 SEC  FLAG FOR MAIN TO AUX
 JSR AUXMOVE
 JSR SETRV RESET VECTOR TO 'START'
 LDA IRQLOC SET IRQ TO HANDLE
 STA IRQ BREAK INSTRUCTIONS
 LDA IRQLOC+1
 STA IRQ+1
 LDA BRKLOC
 STA BRKV
 LDA BRKLOC+1
 STA BRKV+1
 LDA #>DOSV COPY $3D0-3FF TO AUX
 STA MA1L
 STA MA4L
 LDA #<DOSV
 STA MA1H
 STA MA4H
 STA MA2H
 LDA #$FF
 STA MA2L
 SEC
 JSR AUXMOVE
 SKP 1
*** STATIC MAIN PROGRAM AREA ***
 SKP 1
START CLD  RESET POINTS HERE 
 LDX #STKLMT SET ANALYST STACK UPPER
 TXS  LIMIT
 LDA ZFLG
 CMP #$D5
 BNE NOID 
 LDA ZFLG+1
 CMP #$AA
 BEQ START2 IF ID NOT PRESENT 
NOID JSR ZSWAP THEN SWAP 0 PAGE 
 LDA #$D5 & SET ID --> ZFLG:D5 AA 
 STA ZFLG
 LDA #$AA
 STA ZFLG+1
START2 JSR TEXT PRIMARY TEXT MODE
 LDA #$00
 STA CLR80ROM DISABLE 80 COL ROM
 STA CLRIOROM DISABLE INTERNAL I/O
 STA CLRCHAR2 PRIMARY CHAR SET
 STA TLIMIT TRACE ALL
 STA STATUS CLEAR STATUS 
 STA ERRFLG CLEAR FLAGS 
 STA XFLG
 STA TFLG
 STA JFLG
 STA PCL
 STA PCH
 LDX #$F0
 STX SPNT
CLRSTK STA STACK,X = 0
 INX
 BNE CLRSTK
 JSR PRTITLE 
 JMP MONZ
SETRV LDA STARTLOC
 STA SOFTEV
 STA RESET
 LDA STARTLOC+1
 STA SOFTEV+1
 STA RESET+1
 EOR #$A5
 STA SOFTEV+2
 STA FUNNY SAVE FOR REFERENCE
 RTS
INSDS1 LDX PCL
 LDY PCH
 JSR PRYX2
 JSR OUTSP
 LDX #0
INSDST LDA (PCL,X)
INSDS2 LDY #$FF DETERMINE LENGTH OF
 STY LMNEM INSTRUCTION. OPCODE IN
 TAY  ACC. STORED IN LENGTH.
 LSR A INVALID =  0
 BCC IEVEN 1 BYTE = 0
 ROR A 2 BYTE = 1
 BCS ERR 3 BYTE = 2
 AND #$87
IEVEN LSR A
 TAX 
 LDA FMT1,X
 BCC RTMSKZ
 LSR A
 LSR A
 LSR A
 LSR A
RTMSKZ AND #$0F
 CMP #$0F
 BNE GETFMT
ERR LDY #$FF BAD OPCODE
 STY ERRFLG
 INY
 STY LMNEM
 STY RMNEM
 STY FORMAT
 STY LENGTH
RTS1 RTS
GETFMT TAX 
 LDA FMT2,X
 STA FORMAT
 AND #$03
 STA LENGTH
 LDA TFLG BYPASS PRINT FORMATTING
 BNE RTS1 IN TRACE
 TYA 
 AND #$8F
 STA IN+8 TEMP STORAGE
 TYA 
 LDX #31
GETFMT2 DEX
 BMI MNNDX
 CMP OPC65C,X MAKE SUBSTITUTION IF
 BNE GETFMT2 65C02 OPCODE.
 LDA REPL65C,X
MNNDX LDX IN+8
 LDY #$03
 CPX #$8A
 BEQ MNNDX3
MNNDX1 LSR A
 BCC MNNDX3
 LSR A
MNNDX2 LSR A
 ORA #$20
 DEY 
 BNE MNNDX2
 INY 
MNNDX3 DEY 
 BNE MNNDX1
 RTS 
INSTDSP JSR INSDS1
 PHA 
PRNTOP LDA (PCL),Y
 JSR PRBYTE
 LDX #$01
PRNTBL JSR PRBLNK
 CPY LENGTH
 INY 
 BCC PRNTOP
 LDX #$03
 CPY #$03
 BCC PRNTBL
 PLA 
 TAY 
 LDA LMNEM
 BEQ PRMN1
 LDA MNEML,Y
 STA LMNEM
 LDA MNEMR,Y
 STA RMNEM
PRMN1 LDA #$00
 LDY #$05
PRMN2 ASL RMNEM
 ROL LMNEM
 ROL A
 DEY 
 BNE PRMN2
 ADC #$BF
 JSR COUT
 DEX 
 BNE PRMN1
 JSR OUTSP
 LDY LENGTH
 LDX #$05
PRADR1 CPX #$02
 BEQ PRADR5
PRADR2 ASL FORMAT
 BCC PRADR3
 LDA CHAR1,X
 JSR COUT
 LDA CHAR2,X
 BEQ PRADR3
 JSR COUT
PRADR3 DEX 
 BPL PRADR1
 RTS 
PRADR4 DEY 
 BMI PRADR2
 JSR PRBYTE
PRADR5 LDA FORMAT
 CMP #$E8
 LDA (PCL),Y
 BCC PRADR4
 JSR PCADJA
 TAX 
 INX 
 BNE PRNTYX
 INY 
PRNTYX TYA 
PRNTAX JSR PRBYTE 
 TXA 
 JMP PRBYTE
PRBL13 LDX #13
 DFB $2C SKIP NEXT INSTRUCTION
PRBL33 LDX #33
PRBLNK JSR OUTSP PRINT X SPACES
 DEX 
 BNE PRBLNK
 RTS 
PCADJ SEC  UPDATE PC BY LENGTH+1 
PCADJLP LDA LENGTH
PCADJAP JSR PCADJA
 STA PCL
 STY PCH
 RTS
PCADJL LDA LENGTH UPDATE PC BY LENGTH 
PCADJA LDY PCH UPDATE PC BY ACC 
 TAX 
 BPL PCADJ2
 DEY 
PCADJ2 ADC PCL
 BCC RTS2
 INY 
RTS2 RTS  NEW PC IN Y,A 
STEP TXA  F(S)
 BNE SSTEP FIRST TIME
 JSR KYWAIT CTRL-C = BREAK
 CPY #$CA
 BNE STEP2 
 LDA JFLG J = SINGLE STEP
 BEQ SSTEP IF NO JSR, ELSE
 DEC YSAV EXECUTE SUBROUTINE
 PLA
 PLA
 JMP TRCPCS
STEP2 LDA JFLG SPC = SINGLE STEP IF
 BNE STEP3 NOT JSR, ELSE IGNORE
 CPY #$A0 
 BEQ SSTEP
STEP3 CPY #$D3 S OR OPEN APPLE =
 BEQ SSTEP SINGLE STEP ALWAYS
 TYA
 BEQ SSTEPW = 0 FOR OPEN APPLE.
 CPY #$D4 T = ENTER TRACE MODE
 BNE STEP4
 INC TFLG SET TRACE MODE FLAG
 JMP TRACE4 AND ENTER TRACE.
STEP4 CPY #$D8 X = SKIP NEXT INSTRUCTION
 BNE STEP5
 LDA #1 TURN OFF XQT EXECUTION
 STA XFLG
 BNE SSTEP ALWAYS TAKEN
STEP5 CPY #$C0 @ = TEXT MODE
 BNE STEP
 JSR TEXT
SSTEPW LDA #$FF PAUSE TO RELEASE O/A KEY
 JSR WAIT
SSTEP JSR A1PC
SSTEPT DEC YSAV TRACE RE-ENTRY TO STEP
 LDA #0
 STA CV
 STA CH
 JSR VTABZ
 DEC CV TOP OF SCRN AFTER CROUT
 JSR INSTDSP
 JSR CLREOL
 PLA  REMOVE RTS TO NEXTITM 
 PLA
 LDX XFLG
 BEQ NOSKIP
 DEX
 STX XFLG
 STX ERRFLG IN CASE SKIPPING ERROR
 JSR PCADJ
 JMP NXTPC SKIP INSTRUCTION
NOSKIP JMP TSTEP 
PRNTPC LDA #0 PRINT PC AT UPPER LEFT
 STA CH
 LDA PROMPT
 JSR COUT
 LDA PCH
 LDX PCL
 JMP PRNTAX 
TRACEPC JSR CHKVID CHECK/RESET 40/80 MODE
 INC RNDL PRINT PC  
 BNE TRCPC1 EVERY 256 INSTRUCTIONS 
 LDA PROMPT FLASHING '$' FOR TRACE
 EOR #$04 ACTIVITY. $A4->$A0->$A4
 STA PROMPT
 JSR PRNTPC
TRCPC1 LDA JFLG
 BEQ TRACE5
 LDA TLIMIT 
 BEQ TRACE5 FULL TRACE IF TLIMIT=0.
 LDA PCH
 CMP TLIMIT IF PC < TLIMIT PAGE#
 BCC TRACE5 THEN TRACE THRU ELSE
 LDY IDROM CHECK FOR ROM. IF IN
 CPY #$4C ROM EXEC JSR IMMEDIATE
 BEQ TRCPC2 MODE ELSE IF PC >= $D0
 CMP #$D0 THEN TRACE THRU.
 BCS TRACE5
TRCPC2 JSR STPRMPT '#' DENOTES JSR IMMED.
 JSR PRNTPC PRINT EXEC SUBROUTINE
 INC PROMPT '#' -> '$'
 LDA #$FF FORCE PC PRINTING
 STA RNDL AFTER JSR IMMED.
TRCPCS LDA PCL SEE IF PC = $BF00
 BNE TRCPCG
 LDA PCH
 CMP #<MLI
 BNE TRCPCG
 LDY #3 3 PARMS FOR PRODOS MLI
 DFB $2C SKIP NEXT INSTRUCTION
TRCPCG LDY #0 0 PARMS FOR EXEC
 JMP GOPC
TRACE JSR SKPCHR F(T)
 DEC YSAV
 CMP #$BA ':'
 BNE TRACE2
 LDA TLOC+1 'T:' SETS UP TLIMIT
 STA A3L TO STORE VALUE
 LDA TLOC+2
 STA A3H
 RTS
TRACE2 TXA
 BNE TRACE3
TLOC LDA TLIMIT 'T' ALONE PRINTS VALUE
 JSR PRBYTE
 JMP CROUT RTS VIA CROUT
TRACE3 STX TFLG A4<A1T. A4 = BREAK TO STEP
 JSR A1PCLP
TRACE4 INC PROMPT '#' -> '$' 1ST TIME ONLY
 LDA #$FF FORCE VTAB TO TOP OF SCRN
 STA CV WHEN CROUT INC'S CV TO 0
 JSR CROUT (NEEDED FOR 80 COL).
TRACE5 LDX #1 IF PC = A4 THEN ENTER STEP
TRACE6 LDA PCL,X
 CMP A4L,X
 BNE TRACE7
 DEX
 BPL TRACE6
 INX
 BEQ TRACES ALWAYS TAKEN
TRACE7 LDX #0 FOR INSDST
 LDA PB1 BACK TO STEP MODE IF
 BPL TRACE8 CLOSED APPLE PRESSED
TRACES STA KBDSTRB
 STX TFLG CLEAR TRACE FLAG
 JSR TEXT
 JSR STPRMPT PROMPT BACK TO OLD '#'
 LDY YSAV
 DEY
 LDA #$D3 PUT 'S' INTO INPUT BUFFER
 STA IN,Y
 JMP SSTEPT RE-ENTER STEP MODE
TRACE8 LDA PB0 SLOW TRACE IF OPEN APPLE
 BPL TRACE9 PRESSED
 LDA #$FF
 STA RNDL FORCE PC PRINTING
 PHA 
 JSR WAIT
 PLA 
 JSR WAIT
TRACE9 JSR INSDST
TSTEP LDA FUNNY SEE IF RESET VECTOR
 CMP SOFTEV+2 HAS BEEN CHANGED
 BEQ TSTEP2
 JSR SETRV GET BACK RESET CONTROL
TSTEP2 LDA ERRFLG IF BAD OPCODE THEN BRK 
 BNE XBRK
 TAX  = 0
 STX JFLG DISALLOW F(J) IF NO JSR 
 LDA (PCL,X) GET OPCODE
 PHA
 LDY LENGTH
 CPY #2
 BNE TSTEP2A
 AND #$F0 CHECK FOR STA MAINZP OR
 CMP #$80 STA ALTZP INSTRUCTION
 BNE TSTEP2A
 LDA (PCL),Y
 CMP #$C0
 BNE TSTEP2A
 DEY
 LDA (PCL),Y
 INY
 CMP #8
 BCC TSTEP2A
 CMP #$0A
 BCS TSTEP2A
 ROR A ODD/EVEN BIT EORED
 ROR A AGAINST BIT7 OF AUXZP
 EOR RDAUXZP STATE TO SEE IF CHANGE
 BMI TSTEP2B BETWEEN MAIN OR AUX.
TSTEP2A JMP TSTEP3
TSTEP2B JSR ZSWAP GET ANALYST ZERO PAGE
 LDX #STKLMT INTO MAIN AND COPY VARS
 LDA RDAUXZP ON STACK ACROSS. THEN
 BMI AUX2MAIN PUT ANALYST PAGE0 BACK.
MAIN2AUX LDA STACK,X
 STA AUXZP
 STA STACK,X
 STA MAINZP
 DEX
 BPL MAIN2AUX
 STA AUXZP
 BMI ZPDONE ALWAYS TAKEN
AUX2MAIN LDA STACK,X
 STA MAINZP
 STA STACK,X
 STA AUXZP
 DEX
 BPL AUX2MAIN
 STA MAINZP
ZPDONE JSR ZSWAP
 INX
 BEQ TSTEP3 ALWAYS TAKEN
XBRK LDY TFLG
 BEQ SBRK
 DEY 
 STY TFLG
 DEY 
 STY A4L CLEAR OLD BREAK POINT 
 STY A4H
GBRK JSR INSTDSP DISP BRK FOR GO & TRACE
 JSR RGDSP1
 BEQ BRKMON ALWAYS TAKEN
SBRK JSR CROUT
 LDA #5
 STA CV
 JSR VTABZ
 JSR CLREOL ERASE OLD INSTRUCTION
BRKMON JMP ERRMON
XTSX LDX SPNT
 STX XREG
XTXS LDX XREG
UPDSPNT STX SPNT UPDATE SPNT
 CPX #STKLMT+1 STACK OVERFLOW IF
 BCC XBRK IN ANALYST WORK AREA
 JMP PCINC UPDATE PC
TSTEP3 PLA
 BEQ XBRK
 CMP #$20
 BEQ XJSR
 CMP #$60
 BEQ XRTS 
 CMP #$BA
 BEQ XTSX
 CMP #$9A
 BEQ XTXS
 CMP #$7C
 BEQ XJMPATX
 CMP #$4C
 BEQ XJMP
 CMP #$6C
 BEQ XJMPAT
 CMP #$40
 BEQ XRTI
 PHA
 CMP #$5A
 BCC TSTEP4
 TAX
 AND #$1F
 CMP #$1A
 BEQ STACKOP PHX,PLX,PHY,PLY
 TXA
TSTEP4 AND #$9F
 CMP #$08
 BNE TSTEP5
STACKOP JMP STKOPC PHA,PLA,PHP,PLP
TSTEP5 LDX #$08 
XQINIT LDA INITBL-1,X 
 STA XQT,X 
 DEX 
 BNE XQINIT
 PLA  OPCODE
 CMP #$80
 BNE NBRA
 ORA #$10
NBRA AND #$1F
 EOR #$14
 CMP #$04 = BRANCH OFFSET 
 BEQ XQ2 TAKEN IF BRANCH OPCODE 
XQ1 LDA (PCL),Y Y = LENGTH
XQ2 STA XQT,Y XQT   BCS BRNCH (B0 04)
 DEY        NOP 
 BPL XQ1       JMP NBRNCH (CCLR)
 JMP XQJ BRNCH JMP BRANCH (CSET)
XRTI CLC 
 PLA 
 STA STATUS
XRTS LDX SPNT
 INX
 LDA STACK,X
 STA PCL
 INX
 LDA STACK,X
 STA PCH
 STX SPNT
 BNE PCINC ALWAYS TAKEN
XJMPATX INX
 BNE XJMPAT
XJSR STA JFLG OK FOR F(J) 
 CLC
 JSR PCADJL SET Y,A = RTS ADDR 
 PHA
 LDX SPNT
 TYA 
 STA STACK,X
 DEX 
 PLA 
 STA STACK,X
 DEX
 STX SPNT
 LDY #$02
XJMP CLC 
XJMPAT LDA (PCL),Y
 PHA 
 DEY 
 LDA (PCL),Y
 STA PCL
 PLA
 STA PCH
 BCC NEWPC
 DEX
 BNE XJMP
 LDA XREG
 CLC
 JSR PCADJAP
 LDY #1
 BNE XJMP ALWAYS TAKEN
NBRNCH JSR SAVE ALL OTHER OPCODES 
 BMI UPDPC ALWAYS TAKEN
BRANCH JSR SAVE BRANCH WITH COND. MET 
 CLC 
 LDY #$01
 LDA (PCL),Y
 JSR PCADJAP
UPDPC SEC
PCINC JSR PCADJLP
NEWPC LDA TFLG
 BNE TRACEBY BYPASSES NEXTITM
NXTPC JSR CROUT 
 JMP REGDSP
TRACEBY JMP TRACEPC
INITBL NOP 
 NOP 
 JMP NBRNCH
 JMP BRANCH
PULL PHP
 INX
 LDA STACK,X
 TAY
 LDA STATUS PULL FROM STACK AFFECTS
 PHA  N & Z FLAGS
 PLP
 TYA  UPDATE N & Z
 PHP
 PLA
 STA STATUS
 TYA
 PLP
 RTS
STKOPC LDX SPNT STACK OPCODES
 PLA  OPCODE
 TAY
 AND #$10
 BEQ APCODE
 TYA
 ASL A
 BCS OPCX
 ASL A
 ASL A
 BCS XPLY
 LDA YREG XPHY
 BCC PUSH
XPLY JSR PULL
 STA YREG
 BCS UPDSTACK
OPCX ASL A
 ASL A
 BCS XPLX
 LDA XREG XPHX
 BCC PUSH
XPLX JSR PULL
 STA XREG
 BCS UPDSTACK
APCODE TYA
 ASL A
 ASL A
 BMI PULLAP
 BCC XPHP
 LDA ACC XPHA
 BCS PUSH
XPHP LDA STATUS
PUSH STA STACK,X
 DEX
 BNE UPDSTACK
PULLAP BCC XPLP
 JSR PULL XPLA
ACCLOC STA ACC
 BCS UPDSTACK
XPLP JSR PULL
 STA STATUS
UPDSTACK JMP UPDSPNT
IBREAK STA MACC
 PLP  FOR IRQ W/CARD ON
 STX MXREG
 STY MYREG
 PHP
 PLA
 STA MSTATUS
 TSX
 STX MSPNT
 CLD
 PLA
 STA MPCL
 PLA
 STA MPCH
BREAK SEC  IRQ W/ CARD OFF
 LDA MPCL ROM SAVED PC
 SBC #2 AFTER DEC BY 2
 STA PCL
 LDA MPCH
 SBC #0
 STA PCH
 LDX #4
BRKSAVE LDA MACC,X COPY SAVED REGS
 STA ACC,X
 DEX
 BPL BRKSAVE
 LDX #$40 RESTORE ANALYST STACK
 TXS
 JMP GBRK
REGDSP JSR PRBL13 F(CTRL-E)
 LDX #$07
PRFLG LDA CHAR3,X PRINT 'NV-BDIZC' 
 JSR COUT
 DEX 
 BPL PRFLG
 JSR PRBL13
RGDSPB JSR CROUT 
 LDA #$C1 PRINT ACC AND STATUS
 JSR COUT IN BINARY
 JSR OUTEQ
 LDA ACC
 JSR BNDSP
 JSR OUTSP 
 LDA #$D0
 JSR COUT
 JSR OUTEQ
 LDA STATUS
 JSR BNDSP
 JSR PRBL13
 JSR RGDSP1
 JSR INSTDSP DISPLAY INSTRUCTION
 JSR PRBL13 TO BE EXECUTED NEXT
 JMP NEXTITM
RGDSP1 JSR CROUT
 LDX #0 
RDSP1 JSR OUTSP 
 LDA RTBL,X 
 JSR COUT
 LDA #$BD
 JSR COUT
 LDA ACC,X 
 JSR PRBYTE
 INX 
 CPX #4
 BCC RDSP1
 JSR PRBL13
 LDX SPNT PRINT STACK IN THE FORM
 LDY #$01 1NN- XX NN...
 JSR PRYX2
 INX 
 LDY #6 
 JSR OUTSP 
 LDA #$D8
 JSR COUT
 JSR COUT
PRSTK JSR OUTSP 
 LDA STACK,X
 JSR PRBYTE
 INX 
 DEY 
 BNE PRSTK
 JMP PRBL13
BNDSP LDX #$08 INDEX FOR 8 BITS 
NEXTBIT ASL A
 PHA 
 BCS BIT1
 LDA #$30 '0' 
 DFB $2C SKIP NEXT INSTRUCTION
BIT1 LDA #$31 '1' 
 JSR COUT
 PLA 
 DEX 
 BNE NEXTBIT 
 RTS 
BINARY JSR PRA1 F(%)
 JSR OUTSP
 LDA (A1L),Y PRINT A1 IN BINARY. Y=0
 JSR BNDSP
 JMP CROUT
BASCALC PHA
 LSR A
 AND #$03
 ORA #$04
 STA BASH
 PLA 
 AND #$18
 BCC BSCLC2
 ADC #$7F
BSCLC2 STA BASL
 ASL A
 ASL A
 ORA BASL
 STA BASL
 RTS 
BELL LDY #$38 DURATION 
BELL2 LDA #$2B FREQUENCY 
 JSR WAIT
 LDA SPKR
 DEY
 BNE BELL2
 RTS
VIDOUT CMP #$A0 
 BCC NOADV INVERSE, CTRL, OR FLASH
STOADV LDY CH
 STA (BASL),Y
 INC CH
 LDA CH
 CMP #$28
 BCS CR
RTS3 RTS 
NOADV TAY
 BPL STOADV INVERSE OR FLASH
 CMP #$8D
 BEQ CR
 CMP #$88
 BNE RTS3 DON'T PRINT CTRL CHARS.
 DEC CH BACKSPACE
 BPL RTS3
 LDA #$28
 STA CH
 DEC CH
UP LDA #$00
 CMP CV
 BCS RTS4
 DEC CV
VTAB LDA CV
VTABZ JSR BASCALC
 ADC #$00
 STA BASL
RTS4 RTS 
HOME40 LDA #$00
 STA CV
 LDY #$00
 STY CH
CLEOP1 PHA 
 JSR VTABZ
 JSR CLEOLZ
 LDY #$00
 PLA 
 ADC #$00
 CMP #$18
 BCC CLEOP1
 BCS VTAB
CR LDA #$00
 STA CH
 INC CV
 LDA CV
 CMP #$18
 BCC VTABZ
 DEC CV
 LDA #$00
 PHA 
 JSR VTABZ
SCRL1 LDA BASL BASL = CURRENT 
 STA BAS2L BAS2L = OLD 
 LDA BASH
 STA BAS2H
 LDY #$28
 DEY 
 PLA 
 ADC #$01
 CMP #$18
 BCS SCRL3
 PHA 
 JSR VTABZ
SCRL2 LDA (BASL),Y
 STA (BAS2L),Y
 DEY 
 BPL SCRL2
 BMI SCRL1
SCRL3 LDY #$00
 JSR CLEOLZ
 BCS VTAB ALWAYS TAKEN 
CLREOL LDY CH
 LDA FLG8 SEE IF 80 COL VIDEO
 BPL CLEOLZ 80 COL ONLY CLEARS NEXT
 JMP PRBL33 33 SPACES FOLLOWING
CLEOLZ LDA #$A0
CLEOL2 STA (BASL),Y
 INY 
 CPY #$28
 BCC CLEOL2
 RTS 
LWAIT LDA #$70 LIST SCROLL RATE
WAIT SEC 
WAIT2 PHA 
WAIT3 SBC #$01
 BNE WAIT3
 PLA 
 SBC #$01
 BNE WAIT2
 RTS 
NXTA4 INC A4L INCREMENT A4 
 BNE NXTA1
 INC A4H
NXTA1 LDA A1L
 CMP A2L
 LDA A1H
 SBC A2H
 INC A1L
 BNE RTS4B
 INC A1H
RTS4B RTS  CARRY SET IF A1 >= A2 
CTRLC LDY KBD CTRL-C = BREAK TO MONITOR 
 BPL RTS4B 
 STY KBDSTRB
 CPY #$93 CTRL-S = PAUSE 
 BNE CTLC
KYWAIT LDY PB0 F(S) ENTRY POINT
 BMI KYWT2
 LDY KBD
 BPL KYWAIT
 STY KBDSTRB
 DFB $2C
KYWT2 LDY #0 0 = OPEN APPLE PRESSED
CTLC CPY #$83
 BNE RTS4B
 JMP MONZ
RDKEY JMP (KSWL)
KEYIN LDY CH
 LDA (BASL),Y
 PHA
 AND #$3F INVERSE CURSOR
 STA (BASL),Y
 PLA
 BIT KBD
 BPL KEYIN
 ORA #$80
 STA (BASL),Y
 LDA KBD
 BIT KBDSTRB
 RTS 
NOTCR LDA IN,X
 JSR COUT 
 CMP #$88
 BEQ BCKSPC
 CMP #$98 
 BEQ CANCEL 
 CPX #34 BEEP ON LAST 4 CHAR. 
 BCC NOTCR1
 JSR BELL
NOTCR1 INX 
 CPX #38 38 CHARACTERS ALLOWED 
 BCC NXTCHAR 
CANCEL LDA #$DC
 JSR COUT 
GETLNZ JSR CROUT
 LDA PROMPT
 JSR COUT 
 LDX #$01
BCKSPC TXA 
 BEQ GETLNZ
 DEX 
NXTCHAR JSR RDKEY
 CMP #$95 
 BEQ NXTCHAR IGNORE '->'
 CMP #$FF
 BNE NOTDEL
 LDA #$88 DELETE KEY = BACKSPACE
NOTDEL CMP #$88
 BNE CAPTST
 PHA
 JSR COUT BACKSPACE
 JSR OUTSP DELETE CHARACTER
 PLA  BACKSPACE
CAPTST CMP #$E0
 BCC ADDINP
 AND #$DF
ADDINP STA IN,X
 CMP #$8D
 BNE NOTCR
 JSR CLREOL
CROUT LDA #$8D
 BNE COUT
HOME LDA #$8C
 BNE COUT
OUTSP LDA #$A0
 BNE COUT
PRA1 LDY A1H
 LDX A1L
PRYX2 JSR CROUT
 JSR PRNTYX
 LDY #$00
 LDA #$AD
 JMP COUT
MOD8CHK LDA A1L
 AND #$07
 BNE DATAOUT
XAM JSR PRA1 F(.) A1.A2 
DATAOUT JSR OUTSP 
 LDA A1H SEE IF ZERO PAGE
 BNE XAM2
 LDA A1L
 SEC
 SBC #ZFLG
 BCC XAM2 TAKEN IF A1L < ZFLG
 TAX  OTHERWISE GET FROM ZBUF
 LDA ZBUF,X
 DFB $2C SKIP NEXT INSTRUCTION
XAM2 LDA (A1L),Y
 JSR PRBYTE
 JSR NXTA1
 BCC MOD8CHK CARRY CLEAR IF A1<A2 
 RTS 
XAMPM LSR A
 BCC XAM
 LSR A
 LSR A
 LDA A1L 16 BIT ADD. OR SUB. 
 BCC ADD
 SBC A2L SUBTRACT A2 FROM A1 
 STA A1L RESULT IN A1 
 LDA A1H
 SBC A2H
 STA A1H
 JMP PRANS 
ADD ADC A2L ADD A1 AND A2 
 STA A1L RESULT IN A1 
 LDA A1H
 ADC A2H
 STA A1H
PRANS JSR OUTEQ 
 LDA A1H
 JSR PRBYTE
 LDA A1L
PRBYTE PHA 
 LSR A
 LSR A
 LSR A
 LSR A
 JSR PRHEXZ
 PLA 
 AND #$0F
PRHEXZ ORA #$B0
 CMP #$BA
 BCC COUT
 ADC #$06
COUT CMP #$8D
 BNE COUTZ
 STY YSAV1 
 JSR CTRLC
 LDY YSAV1
COUTZ JMP (CSWL)
COUT40 STY YSAV1
 PHA
 CMP #$8C CHECK FOR HOME (CTRL-L)
 BNE COUT40A
 JSR HOME40
 JMP COUT40B
COUT40A JSR VIDOUT
COUT40B PLA
 LDY YSAV1
 RTS 
OUTEQ LDA #$BD
 BNE COUT
BL1 DEC YSAV F(CR) CALLS HERE
 BEQ RTS5 CR ONLY SO IGNORE 
BLANK DEX 
 BNE SETMDZ
 CMP #$BA
 BNE XAMPM
 STA MODE F(:) 
 LDA A2L
 STA (A3L),Y Y=0
 INC XQT HSF BYTE COUNT
 INC A3L
 BNE RTS5
 INC A3H
RTS5 RTS 
SETREG JSR A1PC F(I)
 LDA ACCLOC+1
 STA A3L SETUP REGS FOR F(:)
 LDA ACCLOC+2
 STA A3H
 RTS
SETMODE LDA #0
 STA XQT CLEAR HSF BYTE COUNT
 LDY YSAV 
 LDA IN-1,Y EQUALS :,+,- OR . MODE 
SETMDZ STA MODE
 RTS 
LT LDX #$01 F(<) 
LT2 LDA A2L,X COPY A2 TO A4 
 STA A4L,X
 DEX 
 BPL LT2
 RTS 
MOVE LDA (A1L),Y F(M) A4<A1.A2M 
 STA (A4L),Y
 JSR NXTA4 INCREMENTS A1 AND A4 
 BCC MOVE CARRY CLEAR IF A1<A2 
 RTS 
VFY LDA (A1L),Y F(V) A4<A1.A2V
 CMP (A4L),Y
 BEQ VFYOK
 JSR PRA1
 LDA (A1L),Y
 JSR PRBYTE
 JSR OUTSP
 LDA #$A8 '('
 JSR COUT
 LDA (A4L),Y
 JSR PRBYTE
 LDA #$A9 ')'
 JSR COUT
 JSR LWAIT
VFYOK JSR NXTA4
 BCC VFY
 RTS
LIST JSR A1PC F(L) 
LIST2 JSR INSTDSP 
 JSR PCADJ  
 JSR LWAIT
 BEQ LIST2 ALWAYS TAKEN
A1PC TXA  X=0 IF NO # GIVEN
 BEQ RTS6
A1PCLP LDA A1L,X X=1
 STA PCL,X
 DEX 
 BPL A1PCLP
 LDA #0
 STA JFLG
RTS6 RTS 
SETPRNT JSR CROUT F(P)
 LDA SWITCH2
 LDY MCSWL SAVE CURRENT MONITOR
 LDA MCSWH OUTPUT HOOK.
 STY CSWL
 STA CSWH
 LDY #>PRINIT SIMULATE PR#1
 LDA #<PRINIT
 STY MCSWL
 STA MCSWH
 JSR PRINIT
 LDY MCSWL RESTORE OLD MONITOR
 LDA CSWL OUTPUT HOOK AND SET
 STY CSWL COUT TO PRINTER BY
 STA MCSWL EXCHANGING CSW'S.
 LDY MCSWH
 LDA CSWH
 STY CSWH 
 STA MCSWH
 RTS
BASIC LDA SWITCH2 F(CTRL-B)
 JSR ZSWAP
 LDA #$4C SETUP WARMSTART RE-ENTRY
 STA AMPERV
 LDA JRTSLOC+1
 STA AMPERV+1
 LDA JRTSLOC+2
 STA AMPERV+2
 JSR HOME
 LDX #0 CORRECT PRODOS FLUKE
 STX SPDBYT TO ALLOW BASIC PROGRAM
 INX  ENTRY IN IMMED MODE
 STX STACK+$FC
 STX STACK+$FD
 JMP DOSV
GO JSR A1PC F(G)
 JMP TRCPCG
CRMON JSR BL1 F(CR) 
 JMP MONZ
XQJ LDA STATUS RESTORE REGS
 PHA
 JSR ZSWAP GET PROGRAM 0 PAGE 
 LDA ACC
 LDX XREG
 LDY YREG
 PLP
 JMP XQT EXECUTE
SAVE PHP 
 STA ACC 
 PLA 
 STA STATUS 
 CLD
 STX XREG
 STY YREG
ZSWAP LDX #BAS2H-ZFLG 
ZSWP1 LDA ZFLG,X
 PHA
 LDA ZBUF,X
 STA ZFLG,X
 PLA
 STA ZBUF,X
 DEX
 BPL ZSWP1 
 RTS
ERRMON LDA ERRFLG IF ERROR, 'ERR' ON BRK 
 BEQ MON
PRERR LDX #4 PRINT 'ERR' 
ERROUT LDA ERRMSG,X
 JSR COUT 
 DEX
 BPL ERROUT
MON CLD 
 JSR BELL
MONZ LDX #STKLMT SET STACK UPPER LIMIT
 TXS
 JSR STPRMPT
 JSR GETLNZ 
 JSR ZMODE
 STY ERRFLG CLEAR ERROR FLAG (Y=0) 
NXTITM JSR GETNUM HANDLE HEX DIGS TO 1ST 
 STY YSAV NON-HEX CHAR+1 (Y=INDX)
 LDY #SUBTBL-CHRTBL 
CHRSRCH DEY  ACC = F(ACC) 
 BMI PRERR
 CMP CHRTBL,Y
 BNE CHRSRCH
 JSR TOSUB
NEXTITM LDY YSAV
 JMP NXTITM
DIG LDX #$03 HEX DIGIT NOW IN ACC LO 
 ASL A NIBBLE. KEYS 0-9=00-09 
 ASL A KEYS A-F=FA-FF. MOVE 
 ASL A LO NIBBLE TO HI NIBBLE 
 ASL A
NXTBIT ASL A 4 BIT HEX DIG. INTO A2L 
 ROL A2L A2L TO A2H 
 ROL A2H
 DEX 
 BPL NXTBIT
NXTBAS LDA MODE
 BNE NXTBS2 IF MODE=0 COPY 
 LDA A2H,X A2 TO A1 & A3
 STA A1H,X
 STA A3H,X
NXTBS2 INX 
 BEQ NXTBAS
 BNE NXTCHR
GETNUM LDX #$00 CLEAR A2 TO 0 
 STX A2L
 STX A2H
NXTCHR LDA IN,Y F(ACC) = ACC EOR $B0
 INY  ADC $88 (CARRY SET)
 EOR #$B0 KEYS 0-9=$00-09 
 CMP #$0A
 BCC DIG TAKEN IF KEYS 0-9 
 ADC #$88 KEYS A-F=$FA-FF 
 CMP #$FA 
 BCS DIG TAKEN IF KEYS A-F 
 RTS 
TOSUB TYA  # OF FUNCTION (START=0)
 ASL A MULT BY 2 
 TAY
 LDA SUBTBL+1,Y 
 PHA
 LDA SUBTBL,Y
 PHA 
 LDA MODE OLD MODE FOR F(CR)&F( ) 
ZMODE LDY #$00
 STY MODE
 RTS  RTS TO SUBROUTINE 
EXECJSR LDA JFLG F(J) 
 BNE GOJSR
ERRJ JMP PRERR F(J) ATTEMPTED W/O JSR!
GOJSR JSR UP
 JSR UP
 LDY YSAV GET # OF PARM BYTES
 LDA IN,Y
 CMP #$8D
 BNE NCR
 LDA #$B0 DEFAULT NO PARM (NORM)
 DEC YSAV
NCR INC YSAV
 EOR #$B0
 CMP #10
 BCS ERRJ ONLY 9 PARM BYTES MAX
 TAY  SAVE BYTE COUNT 
GOPC LDX #14 
XQINIT2 LDA INITBL2,X FILL DUMMY BLOCK
 STA XQT,X
 DEX
 BPL XQINIT2
 LDA PCL MOVE JSR ADDR TO XQT
XQLOC1 STA XQT+1
 LDA PCH
 STA XQT+2
 LDX SPNT SET PC = PARM LIST - 1 
 INX
 LDA STACK,X
 STA PCL
 INX
 LDA STACK,X
 STA PCH
 STX SPNT
 TYA  GET PARM BYTES 
 TAX
 BEQ MVPRM1 NO PARM BYTES TO MOVE
MOVPARM LDA (PCL),Y MOVE PARM LIST TO DUMMY
 STA XQT+2,Y 
 DEY 
 BNE MOVPARM
MVPRM1 INX 
 TXA  ADJ PC TO POINT TO INST 
 CLC  FOLLOWING PARM LIST
 JSR PCADJAP
 JMP XQJ EXECUTE JSR IMMED. MODE
INITBL2 JSR $0000 DUMMY BLOCK FOR F(J)
 NOP  9 NOP'S FOR PARM BYTES
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
JRTSLOC JMP JRTS
JRTS JSR SAVE
 LDA JFLG
 BEQ JRTS3 DURING 'G0'
 LDA #0
 STA JFLG
 LDA TFLG
 BEQ JRTS2 DURING 'STEP'
 JMP TRACE5 DURING TRACE IMMEDIATE
JRTS2 LDA #1 UPDATE REG DISPLAY
 STA CV AFTER SUBROUTINE
 JSR VTAB
 JMP RGDSPB
JRTS3 JMP NEXTITM
 SKP 1 
*** THE MINI-ASSEMBLER ***
 SKP 1 
RELADR SBC #$81
 LSR A
 BNE PCERR
 LDY A2H
 LDX A2L
 BNE RELADJ
 DEY 
RELADJ DEX 
 TXA 
 CLC 
 SBC PCL
 STA A2L
 BPL RELADJ2
 INY 
RELADJ2 TYA 
 SBC PCH
PCERR BNE ERRAT
POKEAT LDY LENGTH
POKE LDX A1H,Y
 TXA 
 STA (PCL),Y
 DEY 
 BPL POKE
 JSR UP
 JSR UP
 JSR INSTDSP
 JSR CLREOL
 JSR PCADJ
 JMP MINI
DSS LDA A1H
 JSR INSDS2
 TAX 
 LDA MNEMR,X
 CMP A4L
 BNE NXOPC
 LDA MNEML,X
 CMP A4H
 BNE NXOPC
 LDA A5L
 LDY FORMAT
 CPY #$9D
 BEQ RELADR
 CMP FORMAT
 BEQ POKEAT
NXOPC DEC A1H
 BNE DSS
 INC A5L
 DEC YSAV1
 BEQ DSS
ERRAT LDY YSAV
ERROR TYA 
 TAX 
 JSR PRBLNK
 LDA #$DE
 JSR COUT
 JSR BELL
MINI LDA #$A1
 STA PROMPT
 JSR GETLNZ
 JSR ZMODE
 LDA IN
 CMP #$A3 IF "#" PRESSED, EXIT 
 BNE CKADR 
 JMP STPRMPT VIA NEXTITM 
CKADR CMP #$A0
 BEQ RDMNEM
 JSR GETNUM
 CMP #$93 F(:) 
A1TOPC BNE ERROR
 TXA 
 BEQ ERROR
 JSR A1PCLP
RDMNEM LDA #$03 INDEX FOR 3 CHAR MNEM 
 STA A1H
RDMNEM2 JSR CHARIN
 ASL A
 SBC #$BE
 CMP #$C2 LESS THAN 'A' 
 BCC ERROR NOT ASC LETTER SO ERR 
 ASL A
 ASL A
 LDX #$04 INDEX FOR 5 BITS 
RDMNEM3 ASL A MOVE 5 BIT LETTER CODE 
 ROL A4L (* 3 LETTERS) INTO A4. 
 ROL A4H 26 LETTERS REQ. 5 BITS 
 DEX 
 BPL RDMNEM3
 DEC A1H
 BEQ RDMNEM3
 BPL RDMNEM2
 LDX #$05 INDEX FOR 6 FORMAT BITS 
RDFMT JSR CHARIN
 STY YSAV
 CMP CHAR1,X
 BNE RDFMT2
 JSR CHARIN
 CMP CHAR2,X
 BEQ RDADDR
 LDA CHAR2,X
 BEQ RDFMT3
 CMP #$A4
 BEQ RDFMT3
 LDY YSAV
RDFMT2 CLC 
RDFMT3 DEY 
RDADDR ROL A5L
 CPX #$03
 BNE RDADDR3
 JSR GETNUM
 LDA A2H
 BEQ RDADDR2
 INX 
RDADDR2 STX YSAV1
 LDX #$03
 DEY 
RDADDR3 STX A1H
 DEX 
 BPL RDFMT
 LDA A5L
 ASL A
 ASL A
 ORA YSAV1
 CMP #$20
 BCS RDADDR4
 LDX YSAV1
 BEQ RDADDR4
 ORA #$80
RDADDR4 STA A5L
 STY YSAV
 LDA IN,Y
 CMP #$8D
 BEQ DISAS
 JMP A1TOPC
DISAS JMP DSS
CHARIN LDA IN,Y
 INY 
 CMP #$A0
 BEQ CHARIN
 RTS 
MOD8CK LDA A1L
 AND #$07
 BNE ASCOUT
ASC JSR PRA1 F(CTRL-A)
ASCOUT JSR OUTSP 
 LDA (A1L),Y
 ORA #$80
 CMP #$A0
 BCS PRASC TAKEN IF NORM. OR LCASE
 LDA #$A0 SPACE FOR CTRL OR INV   
PRASC JSR COUT
 JSR NXTA1
 BCC MOD8CK
 RTS
LOAD LDA XQLOC1+1 F(H)
 STA A3L SETUP A3 = XQT+1 FOR HSF
 LDA XQLOC1+2 BUFFER (XQT=BYTE COUNT)
 STA A3H
 RTS
FIND LDA #$FF F(CTRL-F) A4<A1 CTRL-F
 STA A1L HEX SEQUENCE FINDER
 STA A4L
 DEC A4H
 LDX XQT BYTE COUNT
 DEX
 BNE FXEND
 LDA A1H
 CMP #$FF
 BNE FXEND
 DEC A1L
FXEND DEC A1L
 DEX
 BNE FXEND
INCBAS INC A4L
 BNE TESTEND
 INC A4H
 LDA A4H
 CMP #$C0
 BNE TESTEND
 LDA #$C1
 STA A4H
TESTEND LDA A1H
 CMP A4H
 BCC DONE
 BEQ TESTLO
 BNE SETTMP
TESTLO LDA A1L
 CMP A4L
 BCC DONE
SETTMP LDA A4H
 STA A5H
 LDA A4L
 CLC
 ADC XQT
 STA A5L
 BCC SETX
 INC A5H
SETX LDX XQT
 INX
CHGTMP SEC
 LDA A5L
 SBC #$01
 STA A5L
 BCS CMPNUM
 DEC A5H
CMPNUM LDY #$00
 LDA (A5L),Y
 DEX
 CMP XQT,X
 BNE INCBAS
 LDA A5L
 CMP A4L
 BNE CHGTMP
 LDX A4L
 LDA A4H
 JSR PRNTAX
 JSR OUTSP 
 CLV
 BVC INCBAS
DONE JMP CROUT 
RELOC LDA A1H F(R)
 STA A4H
 SEC
 SBC SUMLOC+2
 CMP #$10 IF NEW ORG < +- 4K
 BCC DONE FROM OLD ORG THEN EXIT
 CMP #$F1
 BCS DONE
 LDA A4H
 STA PCH
 STA A3H
 STA MAINRD BE SURE IN MAIN 200-BFFF
 STA MAINWR
 CMP #$D0
 BCC RELOC1
 LDA SWITCH3 R/W ENABLE RAM CARD
 LDA SWITCH3 FOR MOVE TO CARD.
RELOC1 LDA #0 PAGE BOUNDARY ONLY
 STA A4L
 STA PCL
 STA A3L
 LDA SUMLOC+2
 STA A1H
 STA A5L
 LDA SUMLOC+1
 STA A1L
 LDA ENDLOC+1
 STA A2H
 LDA ENDLOC
 STA A2L
 LDA #$20 WILL NEED NEW CHECKSUM
 STA GETSUM
 LDA A1H CALC DIFFERENCE BETWEEN
 SEC  OLD & NEW ORG
 SBC A4H
 STA A5H
 LDA #ERRMSG-SUBTBL
 LSR A DIVIDE BY 2
 TAY  # OF WORDS
 LDX #$FF
RELOC2 INX  CONVERT SUBTBL WORDS
 INX
 LDA SUBTBL,X
 SEC
 SBC A5H
 STA SUBTBL,X
 DEY
 BNE RELOC2
 JSR MOVE NEW ORG<GETSUM.ENDMAIN
 INC A2H
 LDA TITLLOC+1 END OF STATIC PGM AREA
 STA A4L
 LDA TITLLOC+2
 SEC
 SBC A5H
 STA A4H
RELOC3 LDX #0
 JSR INSDST
 LDY LENGTH
 CPY #2 3-BYTE INSTRUCTION ?
 BCC NABS
 LDX #0
 LDA (PCL,X)
 CMP #$2C
 BEQ NABS IGNORE BIT ABSOLUTE
 LDA (PCL),Y Y=2
 LDX A2H IF OLD ENDMAIN WAS $FFNN
 BEQ CHKLO THEN DON'T CHECK ABOVE !!
 CMP A2H SEE IF WITHIN OLD
 BCS NABS START-ENDMAIN
CHKLO CMP A5L
 BCC NABS
 SBC A5H CONVERT TO NEW ADDR
 STA (PCL),Y
NABS JSR PCADJ
 CMP A4L SEE IF PC < NEW END OF
 TYA  STATIC PGM AREA
 SBC A4H
 BCC RELOC3
 JMP (A3L) RUN NEW ORG
SKPCHR LDY YSAV
 LDA IN,Y
 INC YSAV
 RTS
SETVID JSR SKPCHR F(@)
 CMP #$B4 '4'
 BEQ INIT40
 CMP #$B8 '8'
 BEQ INIT80
 DEC YSAV @ ALONE
TEXT LDA RD80VID SET 40 OR 80 COL
 BMI INIT80 TEXT BASED ON RD80VID
INIT40 LDA #<MKEYIN EXECUTE PR#0 TO KEEP
 LDY #>MKEYIN PROPER DOS HOOKS.
 STA MKSWH
 STY MKSWL
 LDA #<MVIDOUT
 LDY #>MVIDOUT
 STA MCSWH
 STY MCSWL
 LDA #40
 STA WNDWDTH
 JSR IN40
 STA SETAN0 VIDEX 80 COL SOFTSWITCH
 STA CLR80COL
 STA CLR80VID
 JSR HOME40
TXT1 LDA LOWSCR
 LDA TXTSET
 RTS
STPRMPT LDA #$A3
 STA PROMPT
 RTS
IN40 LDX #4
MOVE40 LDA HOOK40-1,X
 STA CSWL-1,X
 DEX
 BNE MOVE40
 STX FLG8 SET = 0
RTS7 RTS
CHKVID LDA RD80VID RESET 40/80 COL IF NEEDED
 ASL A BIT 7 INTO CARRY
 LDA FLG8
 BMI CHK80
 BCC RTS7
 BCS IN80 40 -> 80
CHK80 BCS RTS7
 BCC IN40 80 -> 40
 SKP 1
*** 80 COLUMN DRIVER ROUTINE ***
 SKP 1
INIT80 JSR HOME
 JSR PR3
 STA CLRCHAR2
 JSR IN80
 BMI TXT1 ALWAYS TAKEN
IN80 LDX #3
MOVE80 LDA MCSWL,X
 STA CSWL8,X
 LDA HOOK80,X
 STA CSWL,X
 DEX
 BPL MOVE80
 STX FLG8 SET = FF
 RTS
COUT80 JSR EXCHV
 JSR COUTZ80
 JMP EXCHV
COUTZ80 JMP (CSWL8)
KEYIN80 JSR EXCHV
 JSR KEY80
 JMP EXCHV
KEY80 JMP (KSWL8)
EXCHV PHA
 TXA
 PHA
 LDA CH
 LDX MCH
 STA MCH
 STX CH
 LDA CV
 LDX MCV
 STA MCV
 STX CV
 PLA
 TAX
 PLA
 RTS
PRTITLE LDX #$00 PRINT TITLE 
TITLLOC LDA TITLE,X
 BEQ PRADDR 
 JSR COUT
 INX
 BNE TITLLOC 
PRADDR LDA SUMLOC+2 PRINT ORIGIN ADDRESS
 JSR PRBYTE
 LDA #0
 JSR PRBYTE
 JSR CROUT
 JSR DOSUM
 LDA A3L
 CMP CHKSUM
 BNE ERRSUM
 LDA A3H
 CMP CHKSUM+1 
 BNE ERRSUM
 JSR CROUT
 LDA #$CF PRINT 'OK' 
 JSR COUT
 LDA #$CB
 JSR COUT
 JMP CROUT
ERRSUM JMP PRERR 
DOSUM LDA STARTLOC
 STA A1L
 LDA STARTLOC+1
 STA A1H
 LDA ENDLOC 
 STA A2L
 LDA ENDLOC+1 
 STA A2H
 LDX #0
 STX A3L
 STX A3H
GETBYT CLC
 LDA (A1L,X) 
 ADC A3L
 STA A3L
 LDA #0
 ADC A3H
 STA A3H
 JSR NXTA1
 BCC GETBYT
 RTS
INITSUM JSR DOSUM CHKSUM OF START-ENDMAIN 
 LDA A3L
 STA CHKSUM
 LDA A3H
CSUMLOC STA CHKSUM+1
 RTS
 SKP 1
*** PROGRAM DATA AREA ***
 SKP 1
TITLE DFB $8D
 ASC "ANALYST 5.2"
 DFB $8D TITLE MARKS START OF PDA
 ASC "ORG = $"
 DFB $00 
FMT2 DFB 0,33,129,130,90,73,89,77
 DFB 145,146,134,74,133,157
MNEML DFB 28,138
 DFB 28,35,93,139,27,161,157,138
 DFB 29,35,157,139,29,161,28,41
 DFB 25,174,105,168,25,35,36,83
 DFB 27,35,36,83,25,161,173,26
 DFB 165,91,165,172,139,138,174,174
 DFB 168,173,41,138,124,139,21,156
 DFB 109,156,165,105,41,83,132,19
 DFB 52,17,165,105,35,160
MNEMR DFB 216,98
 DFB 90,72,38,98,148,136,84,68
 DFB 200,84,104,68,232,148,196,180
 DFB 8,132,116,180,40,110,116,244
 DFB 204,74,114,242,164,138,6,170
 DFB 118,162,116,198,116,116,68,104
 DFB 178,50,178,114,34,114,26,26
 DFB 38,38,114,114,136,200,196,202
 DFB 38,72,68,68,162,200
FMT1 DFB 240,34,0,51,93,130,0,147
 DFB 243,34,0,51,93,136,0,153
 DFB 240,47,0,51,93,143,0,159
 DFB 240,34,0,59,93,136,0,148
 DFB 253,34,0,51,93,200,0,147
 DFB 17,34,0,51,93,200,0,169
 DFB 241,34,0,51,93,143,0,159
 DFB 241,34,0,51,93,143,0,159
 DFB 38,49,135,154
OPC65C DFB 18,50,82,114
 DFB 146,178,210,242,58,26,137,28
 DFB 20,122,90,156,100,158,116,124
 DFB 60,52
 DFB 76,164,172,180,188,196,204,228
 DFB 236
REPL65C DFB 17,49,81,113,145,177
 DFB 209,241,194,226,52,164,172,196
 DFB 228,92,92,92,92,124,60,52
 DFB 124,160,160,160,160,192,192
 DFB 224,224
CHAR1 DFB 172,169,172,163,168,164
CHAR2 DFB 217,0,216,164,164,0
CHAR3 ASC "CZIDB-VN" 
RTBL ASC "AXYP" 
CHRTBL DFB 152,249,3,190,236  
 DFB 166,164,6,149,5,187
 DFB 0,147,2,167,198,153
 DFB 186,154,239,233,1,191
 DFB 237,158,235,197
SUBTBL DW PRTITLE-1 F(?) DO CHCKSUM OF MAIN
 DW SETVID-1 F(@) SWITCH SCREENS
 DW EXECJSR-1 F(J) EXECUTE JSR  
 DW REGDSP-1 F(CTRL-E) DISPLAY REGS 
 DW STEP-1 F(S) STEP 
 DW SETMODE-1 F(-) 16 BIT SUBTRACTION 
 DW SETMODE-1 F(+) 16 BIT ADDITION 
 DW MOVE-1 F(M) MOVE 
 DW LT-1 F(<) COPY A2 TO A4 & A5 
 DW LIST-1 F(L) LIST 22 LINES 
 DW BASIC-1 F(CTRL-B) DOSWARM VECT.
 DW GO-1 F(G) GO 
 DW SETMODE-1 F(:) STORE 
 DW SETREG-1 F(I) SET INTERNAL PC/REG
 DW SETMODE-1 F(.) XAM 
 DW CRMON-1 F(CR) HANDLE CR 
 DW BLANK-1 F( ) HANDLE SPACES 
 DW ASC-1 F(CTRL-A) DUMP IN ASCII 
 DW MINI-1 F(!) MINI-ASSEMBLER 
 DW VFY-1 F(V) VERIFY
 DW SETPRNT-1 F(P) TO PRINTER
 DW LOAD-1 F(H) LOAD FOR HSF
 DW FIND-1 F(CTRL-F) HEX SEQ. FIND
 DW TRACE-1 F(T) TRACE OR SET TLIMIT
 DW BINARY-1 F(%) VALUE IN BINARY
 DW RELOC-1 F(R) RELOCATOR
 DW CRMON-1 HANDLE CTRL-L AS CR
HOOK40 DW COUT40
 DW KEYIN
HOOK80 DW COUT80
 DW KEYIN80
IRQLOC DW IBREAK
BRKLOC DW BREAK
STARTLOC DW START
ENDLOC DW ENDMAIN
ERRMSG DFB $8D MARKS END OF WORDS
 ASC 'RRE'
 DFB $8D
ENDMAIN DFB $00 = END OF STATIC PGM AREA
