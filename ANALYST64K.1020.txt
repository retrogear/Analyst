 SBTL  MSB ON ORG $8000  SKP 1 **********************************                               **       -< THE ANALYST >-       **                               **          64K VERSION          **                               **       BUILD #1020 12/20/20    **                               ********************************** SKP 1 *** DESCRIPTION ***  SKP 1 ; THIS PROGRAM OPERATES INDEPENDENT OF ROM BUT HAS COM-; MANDS SIMILAR TO THE BUILT IN MONITOR. THE GO AND BREAK; FUNCTIONS HAVE BEEN GREATLY ENHANCED TO DISPLAY; STATUS REGISTER FLAGS AND SET A BREAK POINT. THE MINI; ASSEMBLER HAS BEEN INCLUDED AS WELL AS A HEX SEQUENCE; FINDER. 65C02 OPCODES ARE ALSO SUPPORTED. ZERO PAGE; REFS ARE STORED IN A BUFFER WHICH AVOIDS CONFLICT WITH; THE PROGRAM BEING TRACED. THIS PROGRAM USES THE MIDDLE; OF THE STACK ($132-1B0). IT ALSO UTILIZES A 4K BANK; OF THE 16K LANGUAGE CARD TO KEEP A COPY OF ITSELF; WHICH DOESN'T CONFLICT WITH BASIC OR DOS 3.3.; NMI INTERRUPTS ARE ALSO SUPPORTED AS WELL AS USE OF A; SERIAL TERMINAL FOR CONSOLE I/O TO BE INDEPENDENT OF; SCREEN MEMORY OR GRAPHICS OF THE PROGRAM BEING TRACED. SKP 1 *** COMMANDS *** SKP 1 ; CTRL-F   FIND SPECIFIED HEX SEQUENCE DEFINED BY F(H);      G   GO EXECUTE IN IMMEDIATE MODE  ;      H   LOAD BYTES FOR HSF F(CTRL-F) BY USING H: ;      I   DISPLAY/SET PC/INTERNAL A,X,Y,P,S REGISTERS; CTRL-L   CLEAR PRESENT SCREEN AND HOME CURSOR;      L   LIST DISASSEMBLY OR LOOP IN TRACE MODE.;      M   MOVE BLOCK OF MEMORY;      P   SEND OUTPUT TO PRINTER;      R   RE-ENTER PROGRAM AFTER NMI;      >   COPY ANALYST TO LANGUAGE CARD;      V   VERIFY TWO BLOCKS OF MEMORY;      "   DUMP MEMORY IN ASCII ;      &   EXIT TO DOS AND RETURN FROM DOS;      ?   PRINT ORIGIN ADDRESS & DO INTERNAL CHECKSUM;      @   SET TEXT 40 COL SCREEN OR SERIAL TERMINAL;      <   RANGE DELIMITER;      .   RANGE DELIMITER;      +   16 BIT ADDITION;      -   16 BIT SUBTRACTION;      :   STORE VALUE IN MEMORY;      !   ENTER MINI-ASSEMBLER. <CR> ALONE TO EXIT  SKP 1*** OPERATING NOTES *** SKP 1 ; INPUT LINE LIMITED TO 38 CHARACTERS. BEEPS ON LAST 4. SKP 1; HOME (CTRL-L) ACTS IMMEDIATELY. FOLLOW WITH <CR>. SKP 1; TO DISPLAY PC AND INTERNAL REGISTERS TYPE I <CR>.; TO CHANGE PC AND/OR INTERNAL REGS TYPE 300I:AA XX ; YY PP SS RR <CR>. PC ENTRY BEFORE I OPTIONAL. RR =; STACK TOP REFERENCE SET BY A TXS INSTRUCTION. SKP 1 ; FOR HEX SEQUENCE FINDER TYPE H:N1 N2 N3... <CR> THEN; 1000<2000 CTRL-F <CR>. 8 BYTES MAX BECAUSE IN DS 29. SKP 1 ; TO DUMP MEMORY IN ASCII USE 1000.2000" <CR>.  SKP 1; TO SWITCH TERMINALS TYPE @4 OR @ FOR 40 COL TEXT, @S FOR SERIAL.; @S SHOULD BE FOLLOWED BY > TO COPY NEW SETTINGS TO LANGUAGE CARD.; WITH A TELEVIDEO TERMINAL, USE 9600 BAUD WITH CRLF, NO CROSSOVER SKP 1 ; RESET VECTOR $3F2 CAN BE SET MANUALLY TO ORIGIN ADDR. SKP 1; DO NOT USE THE PRINTER WHEN THE ANALYST IS LOCATED; ON THE RAM CARD. THE PRINTER WILL NOT INITIALIZE.; ALSO RESET WILL NOT RETURN TO THE ANALYST LOCATED; ON THE RAM CARD. SKP 1; TO USE DOS TYPE 3F5<3D0G, THEN USE & TO RE-ENTER.; WILL NOT WORK FROM INTEGER BASIC !! SKP 1* #1008 ADDS LANGUAGE CARD SUPPORT AND REDUCED SIZE FOR NMI BOOT TRACE.* WHEN FIRST BRUN, ANALYST COPIES ITSELF TO UNUSED 4K BANK OF LC AND* NMI HANDLER TO MID-STACK. WHEN NMI OCCURS, MEMORY REGIONS ARE* EXCHANGED TO BRING ANALYST BACK WHILE SAVING THE PROGRAM BEING TRACED.* R WILL RESTORE THE SAVED REGION AND REGS THEN EXECUTE PCREG REAL-TIME SKP 1*** ROM ZERO PAGE EQUATES ***  SKP 1WNDWDTH EQU $21MCSWL EQU $36MCSWH EQU $37MKSWL EQU $38MKSWH EQU $39 SKP 1*** ANALYST EQUATES *** SKP 1STKLMT EQU $D0 #1014 TOP OF STACK (IMMEDIATE)PCL EQU $EF LABEL MARKS PAGE 0 PCH EQU $F0BASL EQU $F1BASH EQU $F2 LABEL USED AS IDENTIFIERZFLG EQU $F3 1 BYTE ID = $AAA1L EQU $F4 A1L-A5H MUST BE IN ORDERA1H EQU $F5 FOR MINI-ASSEMBLER A2L EQU $F6 A2H EQU $F7 A3L EQU $F8 A3H EQU $F9 A4L EQU $FA A4H EQU $FB A5L EQU $FC A5H EQU $FD BAS2L EQU $FEBAS2H EQU $FF LABEL MARKS END OF PAGE 0STACK EQU $0100NMIEXEC EQU $0120 #1013 NMI EXECUTES IN STACKNMIVECT EQU $03FB #1004 HNDL NMI INTERRUPT SKP 1*** ROM EQUATES *** SKP 1KBD EQU $C000KBDSTRB EQU $C010SPKR EQU $C030TXTSET EQU $C051LOWSCR EQU $C054PB0 EQU $C061 OPEN APPLE KEYSWITCH2 EQU $C082PRINIT EQU $C100 PRINTER IN SLOT 1MKEYIN EQU $FD1BMVIDOUT EQU $FDF0**** CCS7710 EQUATES #1005 ****CCSSLOT EQU $20 SLOT# OF CCS7710 CARDACIACTRL EQU $C080 ACIA CONTROL REGISTERACIASTAT EQU $C080 ACIA STATUS REGISTERACIADATA EQU $C081 ACIA DATA REGISTER*GETSUM JSR INITSUM CREATE CHECKSUM OF MAIN  LDA #$2C WHEN FIRST BRUNSUMLOC STA GETSUM DISABLE CHECKSUM SKP 1*** STATIC MAIN PROGRAM AREA *** SKP 1START JMP RESET COLD STARTWARMV JMP REENTER WARM START (BY JSR WARMV)CCSINIT LDY #CCSSLOT #1005 CCS7710 TERMINAL LDA #$03 RESET ACIA STA ACIACTRL,Y LDA #$15 8 BITS,     STA ACIACTRL,Y NO PARITY, ONE STOP BIT RTSCCSKEY STY YSAV2 LDY #CCSSLOTCCSKY1 LDA ACIADATA,Y READ AND DISCARD DATA LDA ACIASTAT,Y ARE CTS AND DCD SIGNALS AND #$0C PRESENT? BNE CCSKY1 NO, WAIT HERECCSKY2 LDA ACIASTAT,Y YES, IS RECEIVER READY? AND #$01 BEQ CCSKY2 NO, LOOP UNTIL READY LDA ACIADATA,Y YES, READ DATA ORA #$80 SET HIGH BIT FOR APPLE II LDY YSAV2 RTSCCSCOUT PHA  SAVE CHAR STY YSAV2 LDY #CCSSLOTCCSOUT2 LDA ACIASTAT,Y TRANSMITTER READY? AND #$02 MASK OTHER BITS BEQ CCSOUT2 NO, PAUSE UNTIL IT IS PLA  RESTORE CHAR STA ACIADATA,Y TRANSMIT DATA LDY YSAV2 RTSINSDS1 LDX PCL LDY PCH JSR PRYX2 JSR OUTSP LDX #0 LDA (PCL,X)INSDS2 LDY #$FF DETERMINE LENGTH OF STY LMNEM INSTRUCTION. OPCODE IN TAY  ACC. STORED IN LENGTH. LSR A INVALID =  0 BCC IEVEN 1 BYTE = 0 ROR A 2 BYTE = 1 BCS ERR 3 BYTE = 2 AND #$87IEVEN LSR A TAX  LDA FMT1,X BCC RTMSKZ LSR A LSR A LSR A LSR ARTMSKZ AND #$0F CMP #$0F BNE GETFMTERR LDY #$FF BAD OPCODE STY ERRFLG INY STY LMNEM STY RMNEM STY FORMAT STY LENGTH RTSGETFMT TAX  LDA FMT2,X STA FORMAT AND #$03 STA LENGTH TYA  AND #$8F STA FMTSAV TEMP STORAGE TYA  LDX #31GETFMT2 DEX BMI MNNDX CMP OPC65C,X MAKE SUBSTITUTION IF BNE GETFMT2 65C02 OPCODE. LDA REPL65C,XMNNDX LDX FMTSAV LDY #$03 CPX #$8A BEQ MNNDX3MNNDX1 LSR A BCC MNNDX3 LSR AMNNDX2 LSR A ORA #$20 DEY  BNE MNNDX2 INY MNNDX3 DEY  BNE MNNDX1 RTS INSTDSP JSR INSDS1 PHA PRNTOP LDA (PCL),Y JSR PRBYTE LDX #$01PRNTBL JSR PRBLNK CPY LENGTH INY  BCC PRNTOP LDX #$03 CPY #$03 BCC PRNTBL PLA  TAY  LDA LMNEM BEQ PRMN1 LDA MNEML,Y STA LMNEM LDA MNEMR,Y STA RMNEMPRMN1 LDA #$00 LDY #$05PRMN2 ASL RMNEM ROL LMNEM ROL A DEY  BNE PRMN2 ADC #$BF JSR COUT DEX  BNE PRMN1 JSR OUTSP LDY LENGTH LDX #$05PRADR1 CPX #$02 BEQ PRADR5PRADR2 ASL FORMAT BCC PRADR3 LDA CHAR1,X JSR COUT LDA CHAR2,X BEQ PRADR3 JSR COUTPRADR3 DEX  BPL PRADR1 RTS PRADR4 DEY  BMI PRADR2 JSR PRBYTEPRADR5 LDA FORMAT CMP #$E8 LDA (PCL),Y BCC PRADR4 JSR PCADJA TAX  INX  BNE PRNTYX INY PRNTYX TYA PRNTAX JSR PRBYTE  TXA  JMP PRBYTEPRBLNK JSR OUTSP PRINT X SPACES DEX  BNE PRBLNK RTS PCADJ SEC  UPDATE PC BY LENGTH+1  LDA LENGTH UPDATE PC BY LENGTHPCADJAP JSR PCADJA UPDATE PC BY ACC STA PCL STY PCH RTSPCADJA LDY PCH SET Y,A = PC+ACC  TAX  BPL PCADJ2 DEY PCADJ2 ADC PCL BCC RTS2 INY RTS2 RTS ACCLOC STA ACCSETBREAK LDX #1 SET BREAKPOINT TO A4 LDA BRKADDR+1 IF GIVEN, ELSE $FFFF. BEQ SETBRK2 BREAKPOINT GIVEN LDA #$FFSETBRK1 STA BRKADDR,X CLEAR OLD BREAKPOINT DEX BPL SETBRK1 BMI RTS2A ALWAYS TAKENSETBRK2 LDA A4L,X SET BREAKPOINT STA BRKADDR,X DEX BPL SETBRK2RTS2A RTSLOAD LDA XQLOC1+1 F(H) LDY XQLOC1+2 SETUP A3 = XQT+1 FOR HSF BNE A3SET BUFFER (XQT=BYTE COUNT)SETRG1 JSR A1PC JSR SAVEPCSETRG2 LDA ACCLOC+1 SETUP REGS FOR F(:) LDY ACCLOC+2A3SET STA A3L STY A3H RTSSETREG TXA  F(I) SET OR DISPLAY REGS. BNE SETRG1 TAKEN IF PC GIVEN. LDY YSAV LDA IN,Y CMP #$8D BNE SETRG2 LDA PCREG I <CR> DISPLAYS REGS. STA PCL LDA PCREG+1 STA PCH JSR RGDSP1 #1018 NO REGDSP JSR INSTDSP DISPLAY INSTRUCTION JMP NEXTITM TO BE EXECUTED NEXTRGDSP1 LDX #0 RDSP1 LDA RTBL,X  JSR COUT LDA #$BD JSR COUT LDA ACC,X  JSR PRBYTE JSR OUTSP INX  CPX #3 BCC RDSP1 LDX #7PRFLG LDA CHAR3,X PRINT 'NV-BDIZC'  JSR COUT DEX  BPL PRFLG JSR CROUT  LDA #$C1 PRINT ACC IN BINARY JSR COUT  JSR OUTEQ LDA ACC JSR BNDSP LDX #3 JSR PRBLNK LDA #$D0 PRINT STATUS IN BINARY JSR COUT JSR OUTEQ LDA STATUS JSR BNDSP JSR CROUT LDA #$D3 JSR COUT JSR OUTEQ LDA SPNT JSR PRBYTE LDA #$BA JSR COUT LDA #$D8 JSR COUT JSR COUT LDY #10 LDX SPNTPRNTSTK JSR OUTSP PRINT STACK BYTES FROM CPX #$FF SPNT TO $FF UP TO 10 #1010 BEQ SAVEPC MAX. INX LDA STACK,X JSR PRBYTE DEY BNE PRNTSTKSAVEPC LDA PCL STA PCREG LDA PCH STA PCREG+1 RTSBNDSP LDX #$08 INDEX FOR 8 BITS NEXTBIT ASL A PHA  BCS BIT1 LDA #$30 '0'  DFB $2C SKIP NEXT INSTRUCTIONBIT1 LDA #$31 '1'  JSR COUT PLA  DEX  BNE NEXTBIT  RTS BASCALC PHA LSR A AND #$03 ORA #$04 STA BASH PLA  AND #$18 BCC BSCLC2 ADC #$7FBSCLC2 STA BASL ASL A ASL A ORA BASL STA BASL RTS BELL LDY #$38 DURATION BELL2 LDA #$2B FREQUENCY  JSR WAIT LDA SPKR DEY BNE BELL2 RTSVIDOUT CMP #$A0  BCC NOADV INVERSE, CTRL, OR FLASHSTOADV LDY CH STA (BASL),Y INC CH LDA CH CMP #$28 BCS CRRTS3 RTS NOADV TAY BPL STOADV INVERSE OR FLASH CMP #$8D BEQ CR CMP #$88 BNE RTS3 DON'T PRINT CTRL CHARS. DEC CH BACKSPACE BPL RTS3 LDA #$28 STA CH DEC CHUP LDA #$00 CMP CV BCS RTS4 DEC CVVTAB LDA CVVTABZ JSR BASCALC ADC #$00 STA BASLRTS4 RTS HOME40 LDA #$00 STA CV LDY #$00 STY CHCLEOP1 PHA  JSR VTABZ JSR CLEOLZ LDY #$00 PLA  ADC #$00 CMP #$18 BCC CLEOP1 BCS VTABCR LDA #$00 STA CH INC CV LDA CV CMP #$18 BCC VTABZ DEC CV LDA #$00 PHA  JSR VTABZSCRL1 LDA BASL BASL = CURRENT  STA BAS2L BAS2L = OLD  LDA BASH STA BAS2H LDY #$28 DEY  PLA  ADC #$01 CMP #$18 BCS SCRL3 PHA  JSR VTABZSCRL2 LDA (BASL),Y STA (BAS2L),Y DEY  BPL SCRL2 BMI SCRL1SCRL3 LDY #$00 JSR CLEOLZ BCS VTAB ALWAYS TAKEN CLREOL LDY CHCLEOLZ LDA #$A0CLEOL2 PHA* LDA FLG8 #1018* BMI CLEOL3 PLA STA (BASL),Y INY BNE CLEOL4 ALWAYS TAKEN PLA  #1018 WAS CLEOL3 JSR COUT LDY CHCLEOL4 CPY #$28 BCC CLEOL2 RTS*CLEARDSP LDX #6 #1018 CLEAR DISPLAY WINDOW*CLRDSP1 LDA DSPTOP* BPL CLRDSP2 HOLD TOP OF DISPLAY* LDA #0 0 <= TOP <= 18.*CLRDSP2 CMP #18* BCC CLRDSP3* LDA #18*CLRDSP3 STA DSPTOP* STA CV CLEAR 6 LINE DISPLAY* DEC CV FROM DSPTOP DOWN AND* TXA  SET CV SO INSTDSP WILL* BEQ RTS4A PRINT AT DSPTOP UPON*CLRDSP4 JSR CROUT EXIT.* JSR CLREOL* DEX* BNE CLRDSP4* BEQ CLRDSP1*RTS4A RTS*LWAIT LDA #$70 LIST SCROLL RATE #1020WAIT SEC WAIT2 PHA WAIT3 SBC #$01 BNE WAIT3 PLA  SBC #$01 BNE WAIT2 RTS NXTA4 INC A4L INCREMENT A4  BNE NXTA1 INC A4HNXTA1 LDA A1L CMP A2L LDA A1H SBC A2H INC A1L BNE RTS4B INC A1HRTS4B RTS  CARRY SET IF A1 >= A2 CTRLC LDY KBD CTRL-C = BREAK TO MONITOR  BPL RTS4B  STY KBDSTRB CPY #$93 CTRL-S = PAUSE  BNE CTLC*KYWAIT LDY PB0 #1019* BMI KYWT2KYWAIT LDY KBD BPL KYWAIT STY KBDSTRB* DFB $2C #1019*KYWT2 LDY #0 0 = OPEN APPLE PRESSEDCTLC CPY #$83 BNE RTS4B JMP MONZRDKEY JMP (KSWL)KEYIN LDY CH LDA (BASL),Y PHA AND #$3F INVERSE CURSOR STA (BASL),Y PLA BIT KBD BPL KEYIN ORA #$80 STA (BASL),Y LDA KBD BIT KBDSTRB RTS NOTCR LDA IN,X JSR COUT  CMP #$88 BEQ BCKSPC CPX #34 BEEP ON LAST 4 CHAR.  BCC NOTCR1 JSR BELLNOTCR1 INX  CPX #38 38 CHARACTERS ALLOWED  BCC NXTCHAR  LDA #$DC JSR COUT GETLNZ JSR CROUT LDA PROMPT JSR COUT  LDX #$01BCKSPC TXA  BEQ GETLNZ DEX NXTCHAR JSR RDKEY CMP #$95  BEQ NXTCHAR IGNORE '->' CMP #$FF BNE NOTDEL LDA #$88 DELETE KEY = BACKSPACENOTDEL CMP #$88 BNE CAPTST PHA JSR COUT BACKSPACE JSR OUTSP DELETE CHARACTER PLA  BACKSPACECAPTST CMP #$E0 BCC ADDINP AND #$DFADDINP STA IN,X CMP #$8D BNE NOTCRCROUT LDA #$8D BNE COUTOUTSP LDA #$A0 BNE COUTPRA1 LDY A1H LDX A1LPRYX2 JSR CROUT JSR PRNTYX LDY #$00 LDA #$AD JMP COUTMOD8CHK LDA A1L AND #$07 BNE DATAOUTXAM JSR PRA1 F(.) A1.A2 DATAOUT JSR OUTSP  LDA A1H SEE IF ZERO PAGE BNE XAM2 LDA A1L SEC SBC #PCL BCC XAM2 TAKEN IF A1L < PCL TAX  OTHERWISE GET FROM ZBUF LDA ZBUF,X DFB $2C SKIP NEXT INSTRUCTIONXAM2 LDA (A1L),Y JSR PRBYTE JSR NXTA1 BCC MOD8CHK CARRY CLEAR IF A1<A2  RTS XAMPM LSR A BCC XAM LSR A LSR A LDA A1L 16 BIT ADD. OR SUB.  BCC ADD SBC A2L SUBTRACT A2 FROM A1  STA A1L RESULT IN A1  LDA A1H SBC A2H STA A1H JMP PRANS ADD ADC A2L ADD A1 AND A2  STA A1L RESULT IN A1  LDA A1H ADC A2H STA A1HPRANS JSR OUTEQ  LDA A1H JSR PRBYTE LDA A1LPRBYTE PHA  LSR A LSR A LSR A LSR A JSR PRHEXZ PLA  AND #$0FPRHEXZ ORA #$B0 CMP #$BA BCC COUT ADC #$06COUT CMP #$8D BNE COUTZ STY YSAV1  JSR CTRLC LDY YSAV1COUTZ JMP (CSWL)COUT40 STY YSAV1 PHA CMP #$8C CHECK FOR HOME (CTRL-L) BNE COUT40A JSR HOME40 JMP COUT40BCOUT40A JSR VIDOUTCOUT40B PLA LDY YSAV1 RTS OUTEQ LDA #$BD BNE COUTBL1 DEC YSAV F(CR) CALLS HERE BEQ RTS5 CR ONLY SO IGNORE BLANK DEX  BNE SETMDZ CMP #$BA BNE XAMPM STA MODE F(:)  LDA A2L STA (A3L),Y Y=0 INC A5L HSF BYTE COUNT INC A3L BNE RTS5 INC A3HRTS5 RTS SETMODE LDA #0 STA A5L CLEAR HSF BYTE COUNT LDY YSAV  LDA IN-1,Y EQUALS :,+,- OR . MODE SETMDZ STA MODE RTS LT LDX #$01 F(<) LT2 LDA A2L,X COPY A2 TO A4  STA A4L,X DEX  BPL LT2 INX  BRKADDRH = 0 STX BRKADDR+1 FLAGS BREAKPOINT GIVEN RTS MOVE LDA (A1L),Y F(M) A4<A1.A2M  STA (A4L),Y JSR NXTA4 INCREMENTS A1 AND A4  BCC MOVE CARRY CLEAR IF A1<A2  RTS VFY LDA (A1L),Y F(V) A4<A1.A2V CMP (A4L),Y BEQ VFYOK JSR PRA1 LDA (A1L),Y JSR PRBYTE JSR OUTSP LDA #$A8 '(' JSR COUT LDA (A4L),Y JSR PRBYTE LDA #$A9 ')' JSR COUT* JSR LWAIT #1020VFYOK JSR NXTA4 BCC VFY RTSLIST JSR A1PC F(L)  JSR SETBREAK NNNN<300L WILL STOP LISTLIST2 JSR INSTDSP AT NNNN JSR PCADJ  * JSR LWAIT #1020 SEC  COMPARE PC TO BRKADDR LDA PCL SBC BRKADDR STA A5L TEMP USE LDA PCH SBC BRKADDR+1 ORA A5L BCC LIST2 TAKEN IF PC < BRKADDR RTSA1PC TXA  X=0 IF NO # GIVEN BEQ RTS6A1PCLP LDA A1L,X X=1 STA PCL,X DEX  BPL A1PCLP* LDA #0 #1018* STA JFLGRTS6 RTS SETPRNT JSR CROUT F(P) LDA SWITCH2 LDY MCSWL SAVE CURRENT MONITOR LDA MCSWH OUTPUT HOOK. STY CSWL STA CSWH LDY #>PRINIT SIMULATE PR#1 LDA #<PRINIT STY MCSWL STA MCSWH JSR PRINIT LDY MCSWL RESTORE OLD MONITOR LDA CSWL OUTPUT HOOK AND SET STY CSWL COUT TO PRINTER BY STA MCSWL EXCHANGING CSW'S. LDY MCSWH LDA CSWH STY CSWH  STA MCSWH RTSEXDOS LDX #9 F(&) = EXIT TO DOSEXDS1 LDA DOSTR-1,X BY PUTTING 3F5<3D0G STA IN-1,X INTO INPUT BUFFER DEX  AND PARSING BNE EXDS1 JMP PARSECRMON JSR BL1 F(CR)  JMP MONZGO JSR A1PC F(G) LDA BRKADDR+1 'GO' WITH NO BREAKPOINT BEQ GOBREAK GIVEN EXECUTED AS A JSR LDY #0 WITH NO PARM BYTES. JMP GOPCGOBREAK LDY #2 'GO' WITH BRKPOINT GIVENLOADRT LDA (A4L),Y SAVES 3 BYTES FROM BREAK STA XQT+3,Y ADDR (XQT+3 = TEMP) AND LDA RTENTRY,Y PUTS JSR REENTER IN ITS STA (A4L),Y PLACE WHICH WILL CAUSE LDA INITBL3,Y A REAL TIME RE-ENTRY TO STA XQT,Y TO ANALYST. DEY BPL LOADRT JSR SAVEPC PUT RUN ADDR INTO PCREG LDX SPNT TXSXQJ LDA STATUS RESTORE REGS PHA JSR ZSWAPT GET PROGRAM 0 PAGE  LDA ACC LDX XREG LDY YREG PLP JMP XQT EXECUTEINITBL3 JMP (PCREG)RTENTRY JSR WARMV DUMMY STATEMENT.REENTER JSR SAVE REAL-TIME RE-ENTRY JSR ZSWAPE WHICH IS CALLED AS PLA  A SUBROUTINE WITH PLA SEC  PLA TO SET PC FROM SBC #2 CALLER ADDRESS. RESTORES STA PCL ORIGINAL 3 BYTES TO BREAK PLA  ADDRESS. SBC #0 STA PCH TSX STX SPNT LDY #2RTREST LDA XQT+3,Y STA (PCL),Y DEY BPL RTREST JSR SAVEPC JSR RGDSP1 #1010 DISPLAY REGS AFTER BREAK JSR INSTDSP JMP MONZSAVE PHP  STA ACC  PLA  STA STATUS  CLD STX XREG STY YREGZSWAPT LDA ZFLG SWAP ALL IF ZFLG = $AA CMP #$AA ELSE SWAP ONLY PCL-BASH BNE ZSWAPSZSWAP LDX #BAS2H-PCL SWAP ALL DFB $2CZSWAPS LDX #BASH-PCLZSWP1 LDA PCL,X LDY ZBUF,X STY PCL,X STA ZBUF,X DEX BPL ZSWP1 ZSWAPRTS RTSZSWAPE LDA ZFLG SWAP ZFLG-BAS2H IF ID CMP #$AA PRESENT. BEQ ZSWAPRTS JSR ZSWAP SWAP ZFLG-BAS2H ONLY. BMI ZSWAPS ALWAYS TAKEN** NMI HANDLER. SWAPS ANALYST FROM LANGUAGE CARD* ON NMI ENTRY, 6502 PUT STATUS AND PC ON STACK*NMIHNDL BIT $C08B RW ENABLE LC BANK 1 BIT $C08B NOT USED BY DOS 3.3 STA $DD02 TEMP SAVE IN LC PLA STA $DD05 6502 STATUS PLA STA $DD00 6502 PC REGISTER LOW PLA STA $DD01 PC REG HIGH STY $DD04 STX $DD03 TSX STX $DD06 STACK POINTER JSR SWAPLC BRING BACK ANALYST LDX #6 RESTORE REGS TO ANALYSTLCREGS LDA $DD00,X STA PCREG,X DEX BPL LCREGS BIT $C08A LC BANK 1 OFF JMP RST1 #1005 BYPASS SET TEXT MODE** F(R) RE-ENTER PROGRAM FROM NMI*RENTRY EQU * #1014 ADDRESS IN ANALYSTRTOFS EQU RENTRY-NMIHNDL CALC OFFSET IN STACKRSENTR EQU NMIEXEC+RTOFS F(R) WILL JMP HERE IN STACK BIT $C08B LC BANK 1 ON BIT $C08B JSR ZSWAPT #1015 GET PROGRAM PAGE 0 JSR SWAPLC BRING BACK PROGRAM BEING TRACED LDA $DD05 STATUS PHA LDA $DD00 PC LOW/HIGH STA XQR+1 LDA $DD01 STA XQR+2 LDA $DD02 ACC LDX $DD03 LDY $DD04 BIT $C08A LC CARD OFF PLPXQTRUN EQU * #1015XQROFS EQU XQTRUN-NMIHNDLXQR EQU NMIEXEC+XQROFS JMP $0000 #1015 SELF-MODIFIED TO JMP PCSWPLCA EQU * #1016SWPOFS EQU SWPLCA-NMIHNDLSWAPLC EQU NMIEXEC+SWPOFS LDY #0 EXCHANGE ANALYST IN LC #1012 STY A1L STY A2L LDA #$D0 STA A1H A1=$D000 LDA #$80 STA A2H A2=$8000SWPLC2 LDA (A1L),Y EXCHANGE (A1) AND (A2) PHA LDA (A2L),Y TAX PLA STA (A2L),Y TXA STA (A1L),Y INY  #1017 BNE SWPLC2 PAGE NOT DONE INC A1H NEXT A1 AND A2 PAGES INC A2H (Y=0) LDA A2H CMP #$8D $8D00 REACHED ? BCC SWPLC2 NO, NEXT PAGE RTSENDHNDL NOP  MARKER FOR END OF NMI HANDLERRESET CLD JSR TEXT PRIMARY TEXT MODE JSR COPYLC #1013 COPY ANALYST TO LC JSR COPYNMI #1013 COPY NMI HANDLER TO MID-STACK LDA #$4C #1004 SETUP NMI HANDLER VECTOR STA NMIVECT LDA NMIXLOC #1016 STA NMIVECT+1 LDA NMIXLOC+1 STA NMIVECT+2RST1 LDX #STKLMT SET ANALYST STACK UPPER TXS  LIMIT LDA ZFLG CMP #$AA BEQ RST2 IF ID NOT PRESENT  JSR ZSWAP THEN SWAP 0 PAGE  LDA #$AA & SET ID --> ZFLG:AA  STA ZFLG*RST2 LDA #$00 #1018* STA JFLGRST2 JSR PRTITLE JMP MONZPRERR LDX #4 PRINT 'ERR' ERROUT LDA ERRMSG,X JSR COUT  DEX BPL ERROUT CLD  JSR BELLMONZ LDX #STKLMT SET STACK UPPER LIMIT TXS DEC BRKADDR+1 INSURE BRKPOINT CLEARED JSR ZSWAPE MAKE SURE ANALYST 0 PAGE. JSR STPRMPT JSR GETLNZ PARSE JSR ZMODE STY ERRFLG CLEAR ERROR FLAG (Y=0)  STY DSPTOP DISPLAY AT TOPNXTITM JSR GETNUM HANDLE HEX DIGS TO 1ST  STY YSAV NON-HEX CHAR+1 (Y=INDX) LDY #SUBTBL-CHRTBL CHRSRCH DEY  ACC = F(ACC)  BMI PRERR CMP CHRTBL,Y BNE CHRSRCH JSR TOSUBNEXTITM LDY YSAV JMP NXTITMDIG LDX #$03 HEX DIGIT NOW IN ACC LO  ASL A NIBBLE. KEYS 0-9=00-09  ASL A KEYS A-F=FA-FF. MOVE  ASL A LO NIBBLE TO HI NIBBLE  ASL ANXTBIT ASL A 4 BIT HEX DIG. INTO A2L  ROL A2L A2L TO A2H  ROL A2H DEX  BPL NXTBITNXTBAS LDA MODE BNE NXTBS2 IF MODE=0 COPY  LDA A2H,X A2 TO A1 & A3 STA A1H,X STA A3H,XNXTBS2 INX  BEQ NXTBAS BNE NXTCHRGETNUM LDX #0 LDA ZFLG SET A2 = 0 ONLY IF CMP #$AA NOT IN DEFERRED STEP BNE NXTCHR MODE. STX A2L STX A2HNXTCHR LDA IN,Y F(ACC) = ACC EOR $B0 INY  ADC $88 (CARRY SET) EOR #$B0 KEYS 0-9=$00-09  CMP #$0A BCC DIG TAKEN IF KEYS 0-9  ADC #$88 KEYS A-F=$FA-FF  CMP #$FA  BCS DIG TAKEN IF KEYS A-F  RTS TOSUB TYA  # OF FUNCTION (START=0) ASL A MULT BY 2  TAY LDA SUBTBL+1,Y  PHA LDA SUBTBL,Y PHA  LDA MODE OLD MODE FOR F(CR)&F( ) ZMODE LDY #$00 STY MODE RTS  RTS TO SUBROUTINE GOPC LDX #5 #1010XQINIT2 LDA INITBL2,X FILL DUMMY BLOCK STA XQT,X DEX BPL XQINIT2 LDA PCL MOVE JSR ADDR TO XQTXQLOC1 STA XQT+1 LDA PCH STA XQT+2 LDX SPNT SET PC = PARM LIST - 1  INX LDA STACK,X STA PCL INX LDA STACK,X STA PCH STX SPNT TYA  GET PARM BYTES  TAX BEQ MVPRM1 NO PARM BYTES TO MOVEMOVPARM LDA (PCL),Y MOVE PARM LIST TO DUMMY STA XQT+2,Y  DEY  BNE MOVPARMMVPRM1 INX  TXA  ADJ PC TO POINT TO INST  CLC  FOLLOWING PARM LIST JSR PCADJAP JMP XQJ EXECUTE JSR IMMED. MODEINITBL2 JSR $0000 DUMMY BLOCK FOR F(J) JMP JRTS #1010 NO J PARMSJRTS JSR SAVE* LDA JFLG #1018* BEQ JRTS3 DURING 'G0' W/O BREAK* LDA #0* STA JFLG* DEC DSPTOP UPDATE REGDSP AFTER JSR.* JSR CLEARDSP 'SKIP' ENTERS HERE* JSR CROUT * JMP REGDSP JMP NEXTITM #1018 WAS JRTS3 SKP 1 *** THE MINI-ASSEMBLER *** SKP 1 RELADR SBC #$81 LSR A BNE PCERR LDY A2H LDX A2L BNE RELADJ DEY RELADJ DEX  TXA  CLC  SBC PCL STA A2L BPL RELADJ2 INY RELADJ2 TYA  SBC PCHPCERR BNE ERRATPOKEAT LDY LENGTHPOKE LDX A1H,Y TXA  STA (PCL),Y DEY  BPL POKE JSR UP JSR UP JSR INSTDSP JSR CLREOL JSR PCADJ JMP MINIDSS LDA A1H JSR INSDS2 TAX  LDA MNEMR,X CMP A4L BNE NXOPC LDA MNEML,X CMP A4H BNE NXOPC LDA A5L LDY FORMAT CPY #$9D BEQ RELADR CMP FORMAT BEQ POKEATNXOPC DEC A1H BNE DSS INC A5L DEC YSAV1 BEQ DSSERRAT LDY YSAVERROR TYA  TAX  JSR PRBLNK LDA #$DE JSR COUT JSR BELLMINI LDA #$A1 STA PROMPT JSR GETLNZ JSR ZMODE LDA IN CMP #$A0 BEQ RDMNEM TXA BNE MINI2 STA YSAV <CR> ALONE EXITS JMP STPRMPT VIA NEXTITMMINI2 JSR GETNUM CMP #$93 F(:) A1TOPC BNE ERROR TXA  BEQ ERROR JSR A1PCLPRDMNEM LDA #$03 INDEX FOR 3 CHAR MNEM  STA A1HRDMNEM2 JSR CHARIN ASL A SBC #$BE CMP #$C2 LESS THAN 'A'  BCC ERROR NOT ASC LETTER SO ERR  ASL A ASL A LDX #$04 INDEX FOR 5 BITS RDMNEM3 ASL A MOVE 5 BIT LETTER CODE  ROL A4L (* 3 LETTERS) INTO A4.  ROL A4H 26 LETTERS REQ. 5 BITS  DEX  BPL RDMNEM3 DEC A1H BEQ RDMNEM3 BPL RDMNEM2 LDX #$05 INDEX FOR 6 FORMAT BITS RDFMT JSR CHARIN STY YSAV CMP CHAR1,X BNE RDFMT2 JSR CHARIN CMP CHAR2,X BEQ RDADDR LDA CHAR2,X BEQ RDFMT3 CMP #$A4 BEQ RDFMT3 LDY YSAVRDFMT2 CLC RDFMT3 DEY RDADDR ROL A5L CPX #$03 BNE RDADDR3 JSR GETNUM LDA A2H BEQ RDADDR2 INX RDADDR2 STX YSAV1 LDX #$03 DEY RDADDR3 STX A1H DEX  BPL RDFMT LDA A5L ASL A ASL A ORA YSAV1 CMP #$20 BCS RDADDR4 LDX YSAV1 BEQ RDADDR4 ORA #$80RDADDR4 STA A5L STY YSAV LDA IN,Y CMP #$8D BEQ DISAS JMP A1TOPCDISAS JMP DSSCHARIN LDA IN,Y INY  CMP #$A0 BEQ CHARIN RTS MOD8CK LDA A1L AND #$07 BNE ASCOUTASC JSR PRA1 F(")ASCOUT JSR OUTSP  LDA (A1L),Y ORA #$80 CMP #$A0 BCS PRASC TAKEN IF NORM. OR LCASE LDA #$A0 SPACE FOR CTRL OR INV   PRASC JSR COUT JSR NXTA1 BCC MOD8CK RTSFIND LDA #$FF F(CTRL-F) A4<A1 CTRL-F STA A1L HEX SEQUENCE FINDER STA A4L DEC A4H LDX A5L STX XQT BYTE COUNT DEX BNE FXEND LDA A1H CMP #$FF BNE FXEND DEC A1LFXEND DEC A1L DEX BNE FXENDINCBAS INC A4L BNE TESTEND INC A4H LDA A4H CMP #$C0 BNE TESTEND LDA #$C1 STA A4HTESTEND LDA A1H CMP A4H BCC DONE BEQ TESTLO BNE SETTMPTESTLO LDA A1L CMP A4L BCC DONESETTMP LDA A4H STA A5H LDA A4L CLC ADC XQT STA A5L BCC SETX INC A5HSETX LDX XQT INXCHGTMP SEC LDA A5L SBC #$01 STA A5L BCS CMPNUM DEC A5HCMPNUM LDY #$00 LDA (A5L),Y DEX CMP XQT,X BNE INCBAS LDA A5L CMP A4L BNE CHGTMP LDX A4L LDA A4H JSR PRNTAX JSR OUTSP  CLV BVC INCBASDONE JMP CROUT COPYNMI LDA NMIXLOC MOVE NMI HANDLER #1016 STA A4L NMIEXEC < NMILOC.NMIEND M STA NMIVECT+1 AND POINT NMIVECT TO IT LDA NMIXLOC+1 STA A4H STA NMIVECT+2 LDA NMILOC STA A1L LDA NMILOC+1 STA A1H LDA NMIEND STA A2L LDA NMIEND+1 STA A2H JSR MOVE RTSCOPYLC BIT $C08B F(S) COPY ANALYST TO LC BANK 1 BIT $C08B R/W BANK 1 D000-DFFF (BASIC LDY #0 IS IN BANK 2) STY A1L SET UP A4<A1.A2M STY A4L LDA BEGIN+1 STA A1H LDA #$D0 USE LC AT $D000 STA A4H LDA #$FF EXTEND A2 TO END OF PAGE STA A2L LDA ENDLOC+1 AT POWER ON, LC IS SET TO BANK 2 STA A2H FOR THE 4K $D000-DFFF JSR MOVE COPY ANALYST IMAGE TO LC BANK 2 BIT $C08A DISABLE LC BANK 2 FOR NOW RTSSETVID LDY YSAV F(@) LDA IN,Y INC YSAV CMP #$B4 '4' BEQ TEXT #1011 NO 80 COL SUPPORT CMP #$D3 'S' SERIAL TERMINAL #1005 BEQ INITSER DEC YSAV @ ALONETEXT LDA #<MKEYIN EXECUTE PR#0 TO KEEP LDY #>MKEYIN PROPER DOS HOOKS. STA MKSWH STY MKSWL LDA #<MVIDOUT LDY #>MVIDOUT STA MCSWH STY MCSWL LDA #40 STA WNDWDTH JSR IN40 JSR HOME40 STA LOWSCR STA TXTSET RTSINITSER JSR CCSINIT #1005 LDX #4MOVESER LDA HOOKSER-1,X STA CSWL-1,X DEX BNE MOVESER* STX FLG8 #1018 RTSSTPRMPT LDA #$A3 STA PROMPT RTSIN40 LDX #4MOVE40 LDA HOOK40-1,X STA CSWL-1,X DEX BNE MOVE40* STX FLG8 #1018 RTSPRTITLE LDX #$00 PRINT TITLE TITLLOC LDA TITLE,X BEQ PRADDR  JSR COUT INX BNE TITLLOC PRADDR LDA SUMLOC+2 PRINT ORIGIN ADDRESS JSR PRBYTE LDA #0 JSR PRBYTE JSR CROUT JSR DOSUM LDA A3L CMP CHKSUM BNE ERRSUM LDA A3H CMP CHKSUM+1  BNE ERRSUM JSR CROUT LDA #$CF PRINT 'OK'  JSR COUT LDA #$CB JSR COUT JMP CROUTERRSUM JMP PRERR DOSUM LDA STARTLOC STA A1L LDA STARTLOC+1 STA A1H LDA ENDLOC  STA A2L LDA ENDLOC+1  STA A2H LDX #0 STX A3L STX A3HGETBYT CLC LDA (A1L,X)  ADC A3L STA A3L LDA #0 ADC A3H STA A3H JSR NXTA1 BCC GETBYT RTSINITSUM JSR DOSUM CHKSUM OF START-ENDMAIN  LDA A3L STA CHKSUM LDA A3H STA CHKSUM+1 RTS SKP 1*** PROGRAM DATA AREA *** SKP 1TITLE DFB $8D ASC "ANALYST 64K #1020 NMI LC" DFB $8D TITLE MARKS START OF PDA ASC "ORG = $" DFB $00 DOSTR ASC "3F5<3D0G" DFB $8DFMT2 DFB 0,33,129,130,90,73,89,77 DFB 145,146,134,74,133,157MNEML DFB 28,138 DFB 28,35,93,139,27,161,157,138 DFB 29,35,157,139,29,161,28,41 DFB 25,174,105,168,25,35,36,83 DFB 27,35,36,83,25,161,173,26 DFB 165,91,165,172,139,138,174,174 DFB 168,173,41,138,124,139,21,156 DFB 109,156,165,105,41,83,132,19 DFB 52,17,165,105,35,160MNEMR DFB 216,98 DFB 90,72,38,98,148,136,84,68 DFB 200,84,104,68,232,148,196,180 DFB 8,132,116,180,40,110,116,244 DFB 204,74,114,242,164,138,6,170 DFB 118,162,116,198,116,116,68,104 DFB 178,50,178,114,34,114,26,26 DFB 38,38,114,114,136,200,196,202 DFB 38,72,68,68,162,200FMT1 DFB 240,34,0,51,93,130,0,147 DFB 243,34,0,51,93,136,0,153 DFB 240,47,0,51,93,143,0,159 DFB 240,34,0,59,93,136,0,148 DFB 253,34,0,51,93,200,0,147 DFB 17,34,0,51,93,200,0,169 DFB 241,34,0,51,93,143,0,159 DFB 241,34,0,51,93,143,0,159 DFB 38,49,135,154OPC65C DFB 18,50,82,114 DFB 146,178,210,242,58,26,137,28 DFB 20,122,90,156,100,158,116,124 DFB 60,52 DFB 76,164,172,180,188,196,204,228 DFB 236REPL65C DFB 17,49,81,113,145,177 DFB 209,241,194,226,52,164,172,196 DFB 228,92,92,92,92,124,60,52 DFB 124,160,160,160,160,192,192 DFB 224,224CHAR1 DFB 172,169,172,163,168,164CHAR2 DFB 217,0,216,164,164,0CHAR3 ASC "CZIDB-VN" RTBL ASC "AXY" CHRTBL DFB 152,249,151 DFB 6,149,5 DFB 0,147,2,167,198,153 DFB 155,154,239,233,1,191 DFB 159,235,197SUBTBL DW PRTITLE-1 F(?) DO CHCKSUM OF MAIN DW SETVID-1 F(@) SWITCH 40/80 COL DW COPYLC-1 F(>) COPY TO LANGUAGE CARD #1008 DW MOVE-1 F(M) MOVE  DW LT-1 F(<) COPY A2 TO A4 & A5  DW LIST-1 F(L) LIST DISASSEMBLY DW GO-1 F(G) GO  DW SETMODE-1 F(:) STORE  DW SETREG-1 F(I) SET INTERNAL PC/REG DW SETMODE-1 F(.) XAM  DW CRMON-1 F(CR) HANDLE CR  DW BLANK-1 F( ) HANDLE SPACES  DW ASC-1 F(") DUMP IN ASCII  DW MINI-1 F(!) MINI-ASSEMBLER  DW VFY-1 F(V) VERIFY DW SETPRNT-1 F(P) TO PRINTER DW LOAD-1 F(H) LOAD FOR HSF DW FIND-1 F(CTRL-F) HEX SEQ. FIND DW EXDOS-1 F(&) EXIT TO DOS DW RSENTR-1 F(R) REAL TIME RE-ENTRY FROM NMI #1014 DW CRMON-1 HANDLE CTRL-L AS CRHOOK40 DW COUT40 DW KEYINHOOKSER DW CCSCOUT #1005 DW CCSKEYNMIXLOC DW NMIEXEC #1016NMILOC DW NMIHNDL #1007NMIEND DW ENDHNDL #1008BEGIN DW GETSUM #1008STARTLOC DW STARTENDLOC DW ENDMAINERRMSG DFB $8D MARKS END OF WORDS ASC 'RRE' DFB $8DENDMAIN DFB $00 = END OF STATIC PGM AREA SKP 1* DYNAMIC PROGRAM AREA * SKP 1CSWL DS 1 ADDR. OF OUTPUT ROUTINE CSWH DS 1KSWL DS 2 ADDR. OF INPUT ROUTINE* JFLG DS 1 SET TO ALLOW F(J) #1018ERRFLG DS 1 SET FOR BAD OPCODE PCREG DS 2,0 DON'T CHANGE THEACC DFB 0 ORDER OF PCREG TO SPNTXREG DFB 0YREG DFB 0STATUS DFB 0SPNT DFB $F0LMNEM DS 1RMNEM DS 1LENGTH DS 1FORMAT DS 1MODE DS 1*FLG8 DS 1 FF = 80 COL, 0 = 40 COL #1018PROMPT DS 1CH DS 1CV DS 1DSPTOP DS 1 TOP OF DISPLAY FOR STEPYSAV DS 1YSAV1 DS 1YSAV2 DS 1 #1005FMTSAV DS 1 TEMP STORAGE FOR INSTDSP #1010BRKADDR DS 2,255 BREAK FOR STEP,TRACE,LISTZBUF DS $100-PCL PAGE ZERO STORAGE BUFFERCHKSUM DS 2 CHKSUM OF STATIC PROG. IN DS 38 KEYIN BUFFER.XQT DS 15 BUFFER FOR F(CTRL-F,G) ENDPGM EQU *